{{> fragment.header.hbs }}

{{# if isDebugPrint }}// include: actor/src/fragments/link/common-imports.fragment.hbs{{/ if }}
{{> actor/src/fragments/link/common-imports.fragment.hbs }}

import {
    {{# each (getApiImportsForViewPage page) as |imp| }}
        {{ imp }},
    {{/ each }}
    _StringOperation,
} from '~/generated/data-api';
import {
    {{ classServiceName link.dataElement.owner }}Impl,
    {{# neq (classServiceName link.dataElement.owner) (classServiceName link.dataElement.target) }}
        {{ classServiceName link.dataElement.target }}Impl,
    {{/ neq }}
} from '~/generated/data-axios';

{{# if (linkHasActionsToImport link) }}
    import {
        {{# each (getFilteredLinkActions link) as |action| }}
            {{ actionFunctionHookName action }},
        {{/ each }}
    } from '../actions';
{{/ if }}

export interface {{ linkComponentName link }}Props {
    {{# if (isPageRefreshable page) }}
        ownerData: {{ classDataName link.dataElement.owner 'Stored' }};
        validation: Map<keyof {{ classDataName link.dataElement.owner 'Stored' }}, string>;
        fetchOwnerData: () => Promise<void>;
    {{ else }}
        ownerData: {{ classDataName link.dataElement.owner '' }};
        validation: Map<keyof {{ classDataName link.dataElement.owner '' }}, string>;
    {{/ if }}
    onChange: (value: {{ classDataName link.dataElement.target '' }} | {{ classDataName link.dataElement.target 'Stored' }} | null) => void;
    disabled: boolean;
    readOnly: boolean;
    editMode: boolean;
}

export function {{ linkComponentName link }}(props: {{ linkComponentName link }}Props) {
    const { ownerData, disabled, readOnly, editMode, {{# if (isPageRefreshable page) }}fetchOwnerData, {{/ if }}onChange, validation } = props;
    const { t } = useTranslation();
    const { openFilterDialog } = useFilterDialog();
    const { openRangeDialog } = useRangeDialog();
    const { downloadFile, extractFileNameFromToken, uploadFile } = fileHandling();
    const { locale: l10nLocale } = useL10N();

    {{# if isDebugPrint }}// include: actor/src/fragments/link/hook-variables.fragment.hbs{{/ if }}
    {{> actor/src/fragments/link/hook-variables.fragment.hbs link=link }}

    {{# each (getFilteredLinkActions link) as |action| }}
        const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}();
    {{/ each }}

    return (
        <AggregationInput
            name="{{ link.dataElement.name }}"
            id="{{ createId link }}"
            {{# unless link.dataElement.isOptional }}required={ true }{{/ unless }}
            label={ t('{{ getTranslationKeyForVisualElement link }}', { defaultValue: '{{ link.label }}' }) as string }
            labelList={[
                {{# each link.parts as |part| }}
                    ownerData.{{ link.dataElement.name }}?.{{ part.attributeType.name }}?.toString() ?? '',
                {{/ each }}
            ]}
            ownerData={ ownerData }
            error={ !!validation.get('{{ link.dataElement.name }}') }
            helperText={ validation.get('{{ link.dataElement.name }}') }
            {{# if link.icon }}
                icon={<MdiIcon path="{{ link.icon.name }}" />}
            {{/ if }}
            disabled={ {{# if link.enabledBy }}!ownerData.{{ link.enabledBy.name }} ||{{/ if }} disabled }
            readOnly={ readOnly }
            editMode={ editMode }
            autoCompleteAttribute={'{{ link.parts.[0].attributeType.name }}'}
            onAutoCompleteSelect={ ({{ link.dataElement.name }}) => {
                // storeDiff('{{ link.dataElement.name }}', {{ link.dataElement.name }});
                onChange({{ link.dataElement.name }} as {{ classDataName link.dataElement.target 'Stored' }});
            } }
            {{# each link.actions as |action| }}
                {{# if action.isViewAction }}
                    onView={ async () => {{ actionFunctionName action }}(ownerData, ownerData?.{{ link.dataElement.name }}!, () => fetchOwnerData()) }
                {{/ if }}
                {{# if action.isCreateAction }}
                    onCreate={ async () => {{ actionFunctionName action }}({{# unless (isActionAccess action) }}ownerData, {{/ unless }}() => {
                        fetchOwnerData();
                    }) }
                {{/ if }}
                {{# if action.isDeleteAction }}
                    onDelete={ async () => {{ actionFunctionName action }}({{# unless (isActionAccess action) }}ownerData, {{/ unless }}ownerData?.{{ link.dataElement.name }}!, () => {
                        fetchOwnerData();
                    }) }
                {{/ if }}
                {{# if action.isRemoveAction }}
                    onRemove={ async () => {
                        // storeDiff('{{ link.dataElement.name }}', null);
                        onChange(null);
                    } }
                {{/ if }}
                {{# if action.isSetAction }}
                    onSet={ async () => {
                        const res = await openRangeDialog<{{ classDataName link.dataElement.target 'Stored' }}, {{ classDataName link.dataElement.target 'QueryCustomizer' }}>({
                            id: '{{ createId link.dataElement }}',
                            columns: {{ link.dataElement.name }}Columns,
                            defaultSortField: ({{{ getDefaultSortParamsForLink link }}} as GridSortItem[])[0],
                            rangeCall: async (queryCustomizer) =>
                                await {{ classServiceName link.dataElement.owner }}Impl.getRangeFor{{ firstToUpper link.dataElement.name }}(ownerData, processQueryCustomizer(queryCustomizer)),
                            single: true,
                            alreadySelectedItems: ownerData.{{ link.dataElement.name }}?.__identifier as GridRowId,
                            filterOptions: {{ link.dataElement.name }}RangeFilterOptions,
                            initialQueryCustomizer: {{ link.dataElement.name }}InitialQueryCustomizer,
                            editMode: editMode,
                            {{# if (linkHasCreateAction link)}}
                                // If there is a value set we cannot predict if is a persisted value or not. If it's persisted
                                // then the backend would error out if we wanted to create a new element on the relation, therefore
                                // we do not allow creation in such cases.
                                createTrigger: !ownerData.{{ link.dataElement.name }} ? async () => {
                                    return new Promise((resolve) => {
                                        {{ actionFunctionName (getCreateActionForLink link) }}({{# unless (isActionAccess action) }}ownerData, {{/ unless }}(result: {{ classDataName link.dataElement.target 'Stored' }}) => {
                                            resolve(result);
                                        }, () => {
                                            resolve(undefined);
                                        });
                                    });
                                } : undefined,
                            {{/ if }}
                        });

                        if (res === undefined) return;
                        {{# if (linkHasCreateAction link)}}
                        if (res && res.resolveSource === 'create') {
                            fetchOwnerData();
                        } else if (res) {
                        {{/ if }}
                            // storeDiff('{{ link.dataElement.name }}', res.value as {{ classDataName link.dataElement.target 'Stored' }});
                            onChange(res.value as {{ classDataName link.dataElement.target 'Stored' }});
                        {{# if (linkHasCreateAction link)}}
                        }
                        {{/ if }}
                    } }
                    {{# if (isAutocompleteAvailable link) }}
                        {{# with (getFirstAutocompleteColumnForLink link) as |column| }}
                            onAutoCompleteSearch={async (searchText: string) => {
                                const queryCustomizer: {{ classDataName link.dataElement.target 'QueryCustomizer' }} = {
                                    ...(searchText?.length ? {
                                        {{ column.attributeType.name }}: [
                                            { operator: _StringOperation.like, value: searchText }
                                        ],
                                    } : {}),
                                    _mask: '{{ link.formattedMask }}',
                                    _orderBy: [
                                        { attribute: '{{ column.attributeType.name }}', descending: false },
                                    ],
                                    _seek: { limit: 10 },
                                };
                                return await {{ classServiceName link.dataElement.owner }}Impl.getRangeFor{{ firstToUpper link.dataElement.name }}(ownerData, processQueryCustomizer(queryCustomizer));
                            } }
                        {{/ with }}
                    {{/ if }}
                {{/ if }}
                {{# if action.isUnsetAction }}
                    onUnset={ async () => {
                        // storeDiff('{{ link.dataElement.name }}', null);
                        onChange(null);
                    } }
                {{/ if }}
            {{/ each }}
        />
    );
}
