import { Box, Typography } from '@mui/material';
import {
    {{# each (getApiImportsForViewPage page) as |imp| }}
        {{ imp }},
    {{/ each }}
} from '~/generated/data-api';
import {
    {{ classServiceName table.dataElement.owner }}Impl,
    {{# neq (classServiceName table.dataElement.owner) (classServiceName table.dataElement.target) }}
        {{ classServiceName table.dataElement.target }}Impl,
    {{/ neq }}
} from '~/generated/data-axios';
{{# if (tableHasActionsToImport table) }}
    import {
        {{# each (getFilteredTableActions table) as |action| }}
            {{ actionFunctionHookName action }},
        {{/ each }}
    } from '../actions';
{{/ if }}
import { applyInMemoryFilters } from '~/utilities';
import { GridLogicOperator } from '@mui/x-data-grid{{ getMUIDataGridPlanSuffix }}';

export const {{ getCustomizationComponentInterfaceKey table }} = '{{ getCustomizationComponentInterface table }}';

export interface {{ tableComponentName table }}Props {
    ownerData: {{ classDataName table.dataElement.owner 'Stored' }};
    isOwnerLoading: boolean;
    fetchOwnerData: () => Promise<void>;
    editMode: boolean;
    isFormUpdateable: () => boolean;
    storeDiff: (attributeName: keyof {{ classDataName table.dataElement.owner 'Stored' }}, value: any) => void;
    validation: Map<keyof {{ classDataName table.dataElement.owner '' }}, string>;
}

export const {{ tableComponentName table }} = (props: {{ tableComponentName table }}Props) => {
    const { getItemParsed, getItemParsedWithDefault, setItemStringified } = useDataStore('sessionStorage');
    const { openFilterDialog } = useFilterDialog();
    const { ownerData, isOwnerLoading, editMode, isFormUpdateable, storeDiff, fetchOwnerData } = props;
    const { t } = useTranslation();
    const { openRangeDialog } = useRangeDialog();
    const { downloadFile, extractFileNameFromToken, uploadFile } = fileHandling();
    const { locale: l10nLocale } = useL10N();
    {{# if (stringValueIsTrue useTableRowHighlighting) }}
    const { service: rowHighlightingHook } = useTrackService<TableRowHighlightingHook<{{ classDataName table.dataElement.target 'Stored' }}>>(`(&(${OBJECTCLASS}=${TABLE_ROW_HIGHLIGHTING_HOOK_INTERFACE_KEY})(component=${ {{~ getCustomizationComponentInterfaceKey table ~}} }))`);
    const rowHighlighting = rowHighlightingHook && rowHighlightingHook();
    const rowStylings: RowStylerConfigured<{{ classDataName table.dataElement.target 'Stored' }}>[] = useMemo(() => {
        return rowHighlighting ? rowHighlighting() : [];
    }, [rowHighlighting]);
    {{/ if }}
    const openCRUDDialog = useCRUDDialog();

    const filterModelKey = `{{ createId table }}-${ownerData.__identifier}-filterModel`;
    const filtersKey = `{{ createId table }}-${ownerData.__identifier}-filters`;
    const [{{ table.dataElement.name }}FilterModel, set{{ ucFirst table.dataElement.name }}FilterModel] = useState<GridFilterModel>(getItemParsedWithDefault(filterModelKey, { items: [] }));
    const [filters, setFilters] = useState<Filter[]>(getItemParsedWithDefault(filtersKey, []));
    const [data, setData] = useState<{{ classDataName table.dataElement.target 'Stored' }}[]>([]);
    const [paginationModel, setPaginationModel] = useState({
        pageSize: {{ calculateTablePageLimit table }},
        page: 0,
    });
    {{# if isDebugPrint }}// include: actor/src/fragments/table/row-selection.fragment.hbs{{/ if }}
    {{> actor/src/fragments/table/row-selection.fragment.hbs table=table }}

    {{# if isDebugPrint }}// include: actor/src/fragments/page/sort-models.fragment.hbs{{/ if }}
    {{> actor/src/fragments/page/sort-models.fragment.hbs dataElement=table.dataElement defaultSortColumn=table.defaultSortColumn columns=table.columns }}

    {{# if isDebugPrint }}// include: actor/src/fragments/relation/hook-variables.fragment.hbs{{/ if }}
    {{> actor/src/fragments/relation/hook-variables.fragment.hbs rel=table }}

    {{# each (getFilteredTableActions table) as |action| }}
        {{# unless action.isFilterAction }}
            const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}();
        {{/ unless }}
    {{/ each }}

    {{# if isDebugPrint }}// include: actor/src/fragments/table/row-actions.fragment.hbs{{/ if }}
    {{> actor/src/fragments/table/row-actions.fragment.hbs table=table page=page }}

    const filterOptions: FilterOption[] = [
        {{# each table.filters as |filter| }}
            {{# if isDebugPrint }}// include: actor/src/fragments/table/filter-option.fragment.hbs{{/ if }}
            {{> actor/src/fragments/table/filter-option.fragment.hbs filter=filter application=application }}
        {{/ each }}
    ];

    const filter = async (id: string, filterOptions: FilterOption[], filters: Filter[]) => {
        const newFilters = await openFilterDialog(id, filterOptions, filters);

        if (Array.isArray(newFilters)) {
            setPaginationModel((prevState) => ({
                ...prevState,
                page: 0,
            }));
            setFilters(newFilters);
            setItemStringified(filtersKey, newFilters);
        }
    };

    {{# if (tableHasDeleteAction table) }}
      const bulkDeleteSelected = useCallback(() => {
        openCRUDDialog<{{ classDataName table.dataElement.target 'Stored' }}>({
          dialogTitle: t('judo.dialogs.crud-bulk.delete.title', { defaultValue: 'Delete selected items' }),
          {{# with (getFirstTitleColumnForTable table) as |column| }}
            itemTitleFn: (item) => item.{{ column.attributeType.name }}!,
          {{ else }}
            itemTitleFn: (item) => t('judo.placeholder', { defaultValue: 'placeholder' }) as string,
          {{/ with }}
          selectedItems: selectedRows.current,
          action: async (item, successHandler: () => void, errorHandler: (error: any) => void) => {
            {{# each table.rowActions as |action| }}
              {{# if action.isDeleteAction }}
                await {{ actionFunctionName action }}({{# unless table.dataElement.isAccess }}ownerData, {{/ unless }}item, successHandler, errorHandler, true);
              {{/ if }}
            {{/ each }}
          },
          onClose: (needsRefresh) => {
            if (needsRefresh) {
              fetchOwnerData();
              setSelectionModel([]); // not resetting on fetchData because refreshes would always remove selections...
            }
          },
        });
      }, []);
      const isBulkDeleteAvailable: () => boolean = useCallback(()=> {
        // every row has the same `__deleteable` flag
        return !!selectionModel.length && {{# if table.enabledBy }}ownerData.{{ table.enabledBy.name }}{{ else }}true{{/ if }} && isFormUpdateable() && !{{ boolValue table.dataElement.isReadOnly }} && !!data[0]?.__deleteable;
      }, [ownerData, data, selectionModel]);
    {{/ if }}
    {{# if (tableHasRemoveAction table) }}
      const bulkRemoveSelected = useCallback(() => {
        openCRUDDialog<{{ classDataName table.dataElement.target 'Stored' }}>({
          dialogTitle: t('judo.dialogs.crud-bulk.remove.title', { defaultValue: 'Remove selected items' }),
          {{# with (getFirstTitleColumnForTable table) as |column| }}
            itemTitleFn: (item) => item.{{ column.attributeType.name }}!,
          {{ else }}
            itemTitleFn: (item) => t('judo.placeholder', { defaultValue: 'placeholder' }) as string,
          {{/ with }}
          selectedItems: selectedRows.current,
          action: async (item, successHandler: () => void, errorHandler: (error: any) => void) => {
            {{# each table.rowActions as |action| }}
              {{# if action.isRemoveAction }}
                await {{ actionFunctionName action }}(ownerData, item, successHandler, errorHandler);
              {{/ if }}
            {{/ each }}
          },
          onClose: (needsRefresh) => {
            if (needsRefresh) {
              fetchOwnerData();
              setSelectionModel([]); // not resetting on fetchData because refreshes would always remove selections...
            }
          },
        });
      }, [ownerData]);
      const isBulkRemoveAvailable: () => boolean = useCallback(()=> {
        return !!selectionModel.length && {{# if table.enabledBy }}ownerData.{{ table.enabledBy.name }}{{ else }}true{{/ if }} && isFormUpdateable() && !{{ boolValue table.dataElement.isReadOnly }};
      }, [ownerData, selectionModel]);
    {{/ if }}
    {{# each (getBulkOperationActionsForTable table) as |action| }}
      const {{ actionFunctionName action }}BulkCall = async (item: {{ classDataName table.dataElement.target 'Stored' }}, successHandler: () => void, errorHandler: (error: any) => void) => {
        await {{ actionFunctionName action }}(item, successHandler, errorHandler, true);
      }
    {{/ each }}
    {{# if (tableHasBulkOperations table) }}
      const bulkCallOperation = useCallback((title: string, actionName: string, action: (item: {{ classDataName table.dataElement.target 'Stored' }}, successHandler: () => void, errorHandler: (error: any) => void) => Promise<void>) => {
        openCRUDDialog<{{ classDataName table.dataElement.target 'Stored' }}>({
          dialogTitle: title,
          {{# with (getFirstTitleColumnForTable table) as |column| }}
            itemTitleFn: (item) => item.{{ column.attributeType.name }}!,
          {{ else }}
            itemTitleFn: (item) => t('judo.placeholder', { defaultValue: 'placeholder' }) as string,
          {{/ with }}
          selectedItems: selectedRows.current,
          action: action,
          onClose: (needsRefresh) => {
            if (needsRefresh) {
              fetchOwnerData();
              setSelectionModel([]); // not resetting on fetchData because refreshes would always remove selections...
            }
          },
          faultPrefix: `{{ classServiceTypeName table.dataElement.target }}.${actionName}`,
        });
      }, []);

      const isBulkOperationAvailable: () => boolean = useCallback(() => {
        return !!selectionModel.length;
      }, [selectionModel]);
    {{/ if }}

    {{# if (stringValueIsTrue useTableContextMenus) }}
        const contextMenuRef = useRef<ContextMenuApi>(null);

        const handleContextMenu = (event: MouseEvent<HTMLElement>) => {
            contextMenuRef.current?.handleContextMenu(event);
        };
    {{/ if }}

    useEffect(() => {
        if (ownerData?.__identifier) {
            const storedFilters = getItemParsed<Filter[]>(filtersKey);
            if (storedFilters !== null) {
                setFilters(storedFilters);
            }

            const storedFilterModel = getItemParsed<GridFilterModel>(filterModelKey);
            if (storedFilterModel !== null) {
                set{{ ucFirst table.dataElement.name }}FilterModel(storedFilterModel);
            }
        }
    }, [ownerData]);

    useEffect(() => {
        const newData = applyInMemoryFilters<{{ classDataName table.dataElement.target 'Stored' }}>(filters, ownerData?.{{ table.dataElement.name }} ?? []);
        setData(newData);
    }, [ownerData?.{{ table.dataElement.name }}, filters]);

    {{# if isUseInlineColumnFilters}}
    useEffect(() => {
        if ({{ table.dataElement.name }}FilterModel.items.every((i) => i.value !== undefined)) {
            setFilters(mapFilterModelToFilters({{ table.dataElement.name }}FilterModel, filterOptions));
        }
    }, [ownerData?.{{ table.dataElement.name }}, {{ table.dataElement.name }}FilterModel]);
    {{/ if }}

    return (
        <>
            <StripedDataGrid
                { ...baseTableConfig }
                {{# if isMUILicensePlanPro }}
                    initialState={ { pinnedColumns: { right: ['actions'] } } }
                {{/ if }}
                pageSizeOptions={[{{ calculateTablePageLimit table }}]}
                sx={ {
                    // overflow: 'hidden',
                    display: 'grid',
                    border: (theme) => props.validation.has('{{ table.dataElement.name }}') ? `2px solid ${theme.palette.error.main}` : undefined,
                    {{# if (stringValueIsTrue useTableRowHighlighting) }}
                    ...transformRowStylings(rowStylings),
                    {{/ if }}
                } }
                slotProps={ {
                {{# if (stringValueIsTrue useTableContextMenus) }}
                  cell: {
                    onContextMenu: handleContextMenu,
                  },
                {{/ if }}
                  filterPanel: {
                    logicOperators: [GridLogicOperator.And],
                  },
                } }
                getRowId={(row: { __identifier: string }) => row.__identifier}
                loading={isOwnerLoading}
                rows={data}
                getRowClassName={ (params: GridRowClassNameParams) => {
                    {{# if (stringValueIsTrue useTableRowHighlighting) }}
                    const customStyle = rowStylings.find(r => r.condition(params));
                    if (customStyle) {
                        return customStyle.name;
                    }
                    {{/ if }}
                    return params.indexRelativeToCurrentPage % 2 === 0 ? 'even' : 'odd';
                } }
                columns={[ ...{{ table.dataElement.name }}Columns, ...columnsActionCalculator('{{ createId table.dataElement }}', {{ table.dataElement.name }}RowActions, t, { shownActions: 2 }) ]}
                disableRowSelectionOnClick
                {{# if (tableHasSelectorColumn table) }}
                  checkboxSelection
                  rowSelectionModel={selectionModel}
                  onRowSelectionModelChange={(newRowSelectionModel) => {
                    setSelectionModel(newRowSelectionModel);
                  }}
                {{/ if }}
                {{# each table.rowActions as |action| }}
                    {{# if action.isViewAction }}
                        onRowClick={ (params: GridRowParams<{{ classDataName table.dataElement.target 'Stored' }}>) => {
                            if (!editMode) {
                                {{ actionFunctionName action }}(ownerData, params.row, () => fetchOwnerData());
                            }
                        } }
                    {{/ if }}
                {{/ each }}
                sortModel={ {{ table.dataElement.name }}SortModel }
                onSortModelChange={(newModel: GridSortModel) => {
                    set{{ ucFirst table.dataElement.name }}SortModel(newModel);
                }}
                {{# if isUseInlineColumnFilters }}
                filterModel={ {{ table.dataElement.name }}FilterModel }
                onFilterModelChange={(newModel: GridFilterModel) => {
                    set{{ ucFirst table.dataElement.name }}FilterModel(newModel);
                    setItemStringified(filterModelKey, newModel);
                }}
                {{/ if }}
                paginationModel={paginationModel}
                onPaginationModelChange={setPaginationModel}
                components={ {
                    Toolbar: () => (
                        <GridToolbarContainer>
                            {{# each table.actions as |action| }}
                                {{# if action.isCreateAction }}
                                    {{# unless page.isPageTypeOperationInput }}
                                        <Button
                                            id="{{ createId action }}"
                                            startIcon={<MdiIcon path="file_document_plus" />}
                                            variant="text"
                                            onClick={() => {{ actionFunctionName action }}({{# unless (isActionAccess action) }}ownerData, {{/ unless }}() => {
                                                fetchOwnerData();
                                            })}
                                            disabled={
                                                   editMode
                                                || isOwnerLoading
                                                || {{# if table.enabledBy }}!ownerData.{{ table.enabledBy.name }} ||{{/ if }} {{ boolValue table.dataElement.isReadOnly }}
                                                || !isFormUpdateable()
                                            }
                                        >
                                            {t('judo.pages.table.create', { defaultValue: 'Create' })}
                                        </Button>
                                    {{/ unless }}
                                {{/ if }}
                                {{# if action.isAddAction }}
                                    <Button
                                        id="{{ createId table.dataElement }}-add"
                                        startIcon={<MdiIcon path="attachment-plus" />}
                                        variant="text"
                                        onClick={ async () => {
                                            const res = await openRangeDialog<{{ classDataName dataElement.target 'Stored' }}, {{ classDataName dataElement.target 'QueryCustomizer' }}>({
                                                id: '{{ createId dataElement }}',
                                                columns: {{ dataElement.name }}Columns,
                                                defaultSortField: {{ dataElement.name }}SortModel[0],
                                                rangeCall: async (queryCustomizer) =>
                                                    await {{ classServiceName dataElement.owner }}Impl.getRangeFor{{ firstToUpper dataElement.name }}(ownerData, processQueryCustomizer(queryCustomizer)),
                                                single: false,
                                                alreadySelectedItems: ownerData.{{ table.dataElement.name }} ? [...ownerData.{{ table.dataElement.name }}] : undefined,
                                                filterOptions: {{ dataElement.name }}RangeFilterOptions,
                                                initialQueryCustomizer: {{ dataElement.name }}InitialQueryCustomizer,
                                            });

                                            if (res) {
                                                const newList = [
                                                    ...(ownerData.{{ table.dataElement.name }} || []),
                                                    ...(res.value as {{ classDataName table.dataElement.target 'Stored' }}[])
                                                ];
                                                storeDiff('{{ table.dataElement.name }}', newList);
                                            }
                                        } }
                                        disabled={
                                               isOwnerLoading
                                            || {{# if table.enabledBy }}!ownerData.{{ table.enabledBy.name }} ||{{/ if }} {{ boolValue table.dataElement.isReadOnly }}
                                            || !isFormUpdateable()
                                        }
                                    >
                                        {t('judo.pages.table.add', { defaultValue: 'Add' })}
                                    </Button>
                                {{/ if }}
                                {{# if action.isClearAction }}
                                    <Button
                                        id="{{ createId table.dataElement }}-clear"
                                        startIcon={<MdiIcon path="link_off" />}
                                        variant="text"
                                        onClick={ async () => {
                                            storeDiff('{{ table.dataElement.name }}', []);
                                        } }
                                        disabled={
                                               isOwnerLoading
                                            || {{# if table.enabledBy }}!ownerData.{{ table.enabledBy.name }} ||{{/ if }} {{ boolValue table.dataElement.isReadOnly }}
                                            || !isFormUpdateable()
                                        }
                                    >
                                        {t('judo.pages.table.clear', { defaultValue: 'Clear' })}
                                    </Button>
                                {{/ if }}
                            {{/ each }}
                            {{# unless isUseInlineColumnFilters }}
                            <Button
                                id="{{ createId table }}-filter"
                                startIcon={<MdiIcon path="filter" />}
                                variant="text"
                                onClick={() => filter('{{ createId table }}-filter', filterOptions, filters)}
                                disabled={isOwnerLoading}
                            >
                                {t('judo.pages.table.set-filters', { defaultValue: 'Set filters' }) + (filters.length !== 0 ? ' (' + filters.length + ')' : '')}
                            </Button>
                            {{ else }}
                                <GridToolbarFilterButton componentsProps={ { button: { variant: 'text' } } }  />
                            {{/ unless }}
                            {{# if (tableHasRemoveAction table) }}
                                {isBulkRemoveAvailable() ? <Button
                                    id="{{ createId table.dataElement }}-bulk-remove"
                                    disabled={isOwnerLoading}
                                    variant="text"
                                    startIcon={<MdiIcon path="link-off" />}
                                    onClick={ () => {
                                        const newList = data.filter(e => !(selectionModel.find(s => s === e.__identifier)));
                                        storeDiff('{{ table.dataElement.name }}', newList);
                                        setSelectionModel([]);
                                    } }>
                                    {t('judo.pages.table.remove.selected', { defaultValue: 'Remove' })}
                                </Button> : null}
                            {{/ if }}
                            {{# if (tableHasDeleteAction table) }}
                                {isBulkDeleteAvailable() ? <Button
                                    id="{{ createId table.dataElement }}-bulk-delete"
                                    disabled={isOwnerLoading || editMode}
                                    variant="text"
                                    startIcon={<MdiIcon path="delete-forever" />}
                                    onClick={bulkDeleteSelected}>
                                    {t('judo.pages.table.delete.selected', { defaultValue: 'Delete' })}
                                </Button> : null}
                            {{/ if }}
                            {{# each (getBulkOperationActionsForTable table) as |bulkOp| }}
                                {isBulkOperationAvailable() ? <Button
                                    id="{{ createId bulkOp }}-bulk-call-operation"
                                    disabled={ isOwnerLoading || editMode{{# if bulkOp.enabledBy }} || selectedRows.current.some(r => !r.{{ bulkOp.enabledBy.name }}){{/ if }} }
                                    variant="text"
                                    {{# if bulkOp.icon }}
                                    startIcon={<MdiIcon path="{{ bulkOp.icon.name }}" />}
                                    {{/ if }}
                                    onClick={() => bulkCallOperation(t('{{ getTranslationKeyForAction bulkOp }}', { defaultValue: '{{ bulkOp.label }}' }), '{{ bulkOp.dataElement.name }}', {{ actionFunctionName bulkOp }}BulkCall)}>
                                    {t('{{ getTranslationKeyForAction bulkOp }}', { defaultValue: '{{ bulkOp.label }}' })}
                                </Button> : null}
                            {{/ each }}
                            <div>{/* Placeholder */}</div>
                        </GridToolbarContainer>
                    ),
                } }
            />
            {{> actor/src/fragments/table/error-feedback.fragment.hbs }}
            {{# if (stringValueIsTrue useTableRowHighlighting) }}
                <RowHighlightLegend rowStylings={rowStylings} />
            {{/ if }}
            {{# if (stringValueIsTrue useTableContextMenus) }}
                <ContextMenu
                    ref={contextMenuRef}
                    data={data}
                    filters={filters}
                    filterOptions={filterOptions}
                    columns={ {{ table.dataElement.name }}Columns }
                    onFilterByCell={ (filter: Filter) => {
                        {{# if isUseInlineColumnFilters}}
                            const newFilterModel = {
                                ...{{ table.dataElement.name }}FilterModel,
                                items: [...{{ table.dataElement.name }}FilterModel.items, mapFilterToFilterModel(filter)],
                            };
                            set{{ ucFirst table.dataElement.name }}FilterModel(newFilterModel);
                            setItemStringified(filterModelKey, newFilterModel);
                        {{ else }}
                            const newFilters = [...filters, filter];
                            setFilters(newFilters);
                            setItemStringified(filtersKey, newFilters);
                        {{/ if }}
                    } }
                    onExcludeByCell={ (filter: Filter) => {
                        {{# if isUseInlineColumnFilters}}
                            const newFilterModel = {
                                ...{{ table.dataElement.name }}FilterModel,
                                items: [...{{ table.dataElement.name }}FilterModel.items, mapFilterToFilterModel(filter)],
                            };
                            set{{ ucFirst table.dataElement.name }}FilterModel(newFilterModel);
                            setItemStringified(filterModelKey, newFilterModel);
                        {{ else }}
                            const newFilters = [...filters, filter];
                            setFilters(newFilters);
                            setItemStringified(filtersKey, newFilters);
                        {{/ if }}
                    } }
                />
            {{/ if }}
        </>
    );
};
