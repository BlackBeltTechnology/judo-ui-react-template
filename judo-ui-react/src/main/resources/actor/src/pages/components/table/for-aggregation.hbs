import {
    {{# each (getApiImportsForViewPage page) as |imp| }}
        {{ imp }},
    {{/ each }}
} from '~/generated/data-api';
import {
    {{ classServiceName table.dataElement.owner }}Impl,
    {{# neq (classServiceName table.dataElement.owner) (classServiceName table.dataElement.target) }}
        {{ classServiceName table.dataElement.target }}Impl,
    {{/ neq }}
} from '~/generated/data-axios';
{{# if (tableHasActionsToImport table) }}
    import {
        {{# each (getFilteredTableActions table) as |action| }}
            {{ actionFunctionHookName action }},
        {{/ each }}
    } from '../actions';
{{/ if }}
import { applyInMemoryFilters } from '~/utilities';

export interface {{ tableComponentName table }}Props {
    ownerData: {{ classDataName table.dataElement.owner 'Stored' }};
    isOwnerLoading: boolean;
    fetchOwnerData: () => Promise<void>;
    editMode: boolean;
    isFormUpdateable: () => boolean;
    storeDiff: (attributeName: keyof {{ classDataName table.dataElement.owner 'Stored' }}, value: any) => void;
}

export const {{ tableComponentName table }} = (props: {{ tableComponentName table }}Props) => {
    const { openFilterDialog } = useFilterDialog();
    const { ownerData, isOwnerLoading, editMode, isFormUpdateable, storeDiff, fetchOwnerData } = props;
    const { t } = useTranslation();
    const { openRangeDialog } = useRangeDialog();
    const { downloadFile, extractFileNameFromToken, uploadFile } = fileHandling();
    const { locale: l10nLocale } = useL10N();

    const [filters, setFilters] = useState<Filter[]>([]);
    const [data, setData] = useState<{{ classDataName table.dataElement.target 'Stored' }}[]>([]);
    const [paginationModel, setPaginationModel] = useState({
        pageSize: {{ calculateTablePageLimit table }},
        page: 0,
    });

    {{# if isDebugPrint }}// include: actor/src/fragments/page/sort-models.fragment.hbs{{/ if }}
    {{> actor/src/fragments/page/sort-models.fragment.hbs dataElement=table.dataElement defaultSortColumn=table.defaultSortColumn columns=table.columns }}

    {{# if isDebugPrint }}// include: actor/src/fragments/relation/hook-variables.fragment.hbs{{/ if }}
    {{> actor/src/fragments/relation/hook-variables.fragment.hbs rel=table }}

    {{# each (getFilteredTableActions table) as |action| }}
        {{# unless action.isFilterAction }}
            const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}();
        {{/ unless }}
    {{/ each }}

    {{# if isDebugPrint }}// include: actor/src/fragments/table/row-actions.fragment.hbs{{/ if }}
    {{> actor/src/fragments/table/row-actions.fragment.hbs table=table page=page }}

    {{# each table.actions as |action| }}
        {{# unless table.dataElement.isMemberTypeTransient }}
            {{# if action.isAddAction }}
                {{# if isDebugPrint }}// include: actor/src/fragments/action/range-call.fragment.hbs{{/ if }}
                {{> actor/src/fragments/action/range-call.fragment.hbs dataElement=table.dataElement }}
                {{# if isDebugPrint }}// include: actor/src/fragments/action/selection-model.fragment.hbs{{/ if }}
                {{> actor/src/fragments/action/selection-model.fragment.hbs dataElement=table.dataElement }}
            {{/ if }}
        {{/ unless }}
    {{/ each }}

    const filterOptions: FilterOption[] = [
        {{# each table.filters as |filter| }}
            {{# if isDebugPrint }}// include: actor/src/fragments/table/filter-option.fragment.hbs{{/ if }}
            {{> actor/src/fragments/table/filter-option.fragment.hbs filter=filter application=application }}
        {{/ each }}
    ];

    const filter = async (id: string, filterOptions: FilterOption[], filters: Filter[]) => {
        const newFilters = await openFilterDialog(id, filterOptions, filters);

        if (Array.isArray(newFilters)) {
            setPaginationModel((prevState) => ({
                ...prevState,
                page: 0,
            }));
            setFilters(newFilters);
        }
    };

    const contextMenuRef = useRef<ContextMenuApi>(null);

    const handleContextMenu = (event: MouseEvent<HTMLElement>) => {
        contextMenuRef.current?.handleContextMenu(event);
    };

    useEffect(() => {
        const newData = applyInMemoryFilters<{{ classDataName table.dataElement.target 'Stored' }}>(filters, ownerData?.{{ table.dataElement.name }} ?? []);
        setData(newData);
    }, [ownerData?.{{ table.dataElement.name }}, filters]);

    return (
        <>
            <{{ muiDataGridComponent }}
                { ...baseTableConfig }
                pageSizeOptions={[{{ calculateTablePageLimit table }}]}
                sx={ {
                    // overflow: 'hidden',
                    display: 'grid',
                } }
                slotProps={ {
                    cell: {
                        onContextMenu: handleContextMenu,
                    },
                } }
                getRowId={(row: { __identifier: string }) => row.__identifier}
                loading={isOwnerLoading}
                rows={data}
                getRowClassName={() => "data-grid-row"}
                getCellClassName={() => "data-grid-cell"}
                columns={[ ...{{ table.dataElement.name }}Columns, ...columnsActionCalculator('{{ createId table.dataElement }}', {{ table.dataElement.name }}RowActions, { shownActions: 2 }) ]}
                disableRowSelectionOnClick
                {{# each table.rowActions as |action| }}
                    {{# if action.isViewAction }}
                        onRowClick={ (params: GridRowParams<{{ classDataName table.dataElement.target 'Stored' }}>) => {
                            if (!editMode) {
                                {{ actionFunctionName action }}(ownerData, params.row);
                            }
                        } }
                    {{/ if }}
                {{/ each }}
                sortModel={ {{ table.dataElement.name }}SortModel }
                onSortModelChange={(newModel: GridSortModel) => {
                    set{{ ucFirst table.dataElement.name }}SortModel(newModel);
                }}
                paginationModel={paginationModel}
                onPaginationModelChange={setPaginationModel}
                components={ {
                    Toolbar: () => (
                        <GridToolbarContainer>
                            {{# each table.actions as |action| }}
                                {{# if action.isCreateAction }}
                                    {{# unless page.isPageTypeOperationInput }}
                                        <Button
                                            id="{{ createId action }}"
                                            startIcon={<MdiIcon path="file_document_plus" />}
                                            variant="text"
                                            onClick={() => {{ actionFunctionName action }}({{# unless (isActionAccess action) }}ownerData, {{/ unless }}() => {
                                                fetchOwnerData();
                                            })}
                                            disabled={
                                                   editMode
                                                || isOwnerLoading
                                                || {{# if child.enabledBy }}!ownerData.{{ child.enabledBy.name }} ||{{/ if }} {{ boolValue child.dataElement.isReadOnly }}
                                                || !isFormUpdateable()
                                            }
                                        >
                                            {t('judo.pages.table.create', { defaultValue: 'Create' })}
                                        </Button>
                                    {{/ unless }}
                                {{/ if }}
                                {{# unless table.dataElement.isMemberTypeTransient }}
                                    {{# if action.isAddAction }}
                                        <Button
                                            id="{{ createId table.dataElement }}-add"
                                            startIcon={<MdiIcon path="attachment-plus" />}
                                            variant="text"
                                            onClick={ async () => {
                                                const res = await {{ table.dataElement.name }}RangeCall();

                                                if (res) {
                                                    storeDiff('{{ table.dataElement.name }}', [
                                                        ...(ownerData.{{ table.dataElement.name }} || []),
                                                        ...(res as {{ classDataName table.dataElement.target 'Stored' }}[])
                                                    ]);
                                                }
                                            } }
                                            disabled={
                                                   isOwnerLoading
                                                || {{# if child.enabledBy }}!ownerData.{{ child.enabledBy.name }} ||{{/ if }} {{ boolValue child.dataElement.isReadOnly }}
                                                || !isFormUpdateable()
                                            }
                                        >
                                            {t('judo.pages.table.add', { defaultValue: 'Add' })}
                                        </Button>
                                    {{/ if }}
                                    {{# if action.isClearAction }}
                                        <Button
                                            id="{{ createId table.dataElement }}-clear"
                                            startIcon={<MdiIcon path="link_off" />}
                                            variant="text"
                                            onClick={ async () => {
                                                storeDiff('{{ table.dataElement.name }}', []);
                                            } }
                                            disabled={
                                                   isOwnerLoading
                                                || {{# if child.enabledBy }}!ownerData.{{ child.enabledBy.name }} ||{{/ if }} {{ boolValue child.dataElement.isReadOnly }}
                                                || !isFormUpdateable()
                                            }
                                        >
                                            {t('judo.pages.table.clear', { defaultValue: 'Clear' })}
                                        </Button>
                                    {{/ if }}
                                {{/ unless }}
                            {{/ each }}
                            <Button
                                id="{{ createId table }}-filter"
                                startIcon={<MdiIcon path="filter" />}
                                variant="text"
                                onClick={() => filter('{{ createId table }}-filter', filterOptions, filters)}
                                disabled={isOwnerLoading}
                            >
                                {t('judo.pages.table.set-filters', { defaultValue: 'Set filters' }) + (filters.length !== 0 ? ' (' + filters.length + ')' : '')}
                            </Button>
                        </GridToolbarContainer>
                    ),
                } }
            />
            <ContextMenu
                ref={contextMenuRef}
                data={data}
                filters={filters}
                filterOptions={filterOptions}
                onFiltersUpdated={ (newFilters: Filter[]) => {
                    setPaginationModel((prevState) => ({
                        ...prevState,
                        page: 0,
                    }));
                    setFilters(newFilters);
                } }
            />
        </>
    );
};
