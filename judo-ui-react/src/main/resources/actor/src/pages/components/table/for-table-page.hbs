import {
    {{# each (getApiImportsForTablePage page) as |imp| }}
        {{ imp }},
    {{/ each }}
} from '~/generated/data-api';
import {
    {{# unless page.dataElement.isAccess }}
        {{ classServiceName table.dataElement.owner }}Impl,
        {{# neq (classServiceName table.dataElement.owner) (classServiceName table.dataElement.target) }}
            {{ classServiceName table.dataElement.target }}Impl,
        {{/ neq }}
    {{ else }}
        {{ dataElementRelationName page.dataElement }}Impl,
    {{/ unless }}
} from '~/generated/data-axios';
{{# if (tableHasActionsToImport table) }}
    import {
        {{# each (getFilteredTableActions table) as |action| }}
            {{ actionFunctionHookName action }},
        {{/ each }}
    } from '../actions';
{{/ if }}

export interface {{ tableComponentName table }}Props {
    {{# unless page.dataElement.isAccess }}
        ownerData: JudoIdentifiable<{{ classDataName table.dataElement.owner '' }}>
    {{/ unless }}
    isOwnerLoading: boolean;
    setIsOwnerLoading: (value: boolean) => void;
}

export const {{ tableComponentName table }} = forwardRef<RefreshableTable, {{ tableComponentName table }}Props>((props, ref) => {
    const { isOwnerLoading, setIsOwnerLoading{{# unless page.dataElement.isAccess }}, ownerData{{/ unless }} } = props;
    const { t } = useTranslation();
    const { openFilterDialog } = useFilterDialog();
    const { openRangeDialog } = useRangeDialog();
    const { downloadFile, extractFileNameFromToken, uploadFile } = fileHandling();
    const { locale: l10nLocale } = useL10N();
    const handleFetchError = useErrorHandler(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Fetch))`);

    const [data, setData] = useState<GridRowModel<{{ classDataName table.dataElement.target 'Stored' }}>[]>([]);
    const [rowCount, setRowCount] = useState<number>(0);
    const [sortModel, setSortModel] = useState<GridSortModel>({{{ getDefaultSortParamsForTable table }}});
    const [lastItem, setLastItem] = useState<{{ classDataName table.dataElement.target 'Stored' }}>();
    const [firstItem, setFirstItem] = useState<{{ classDataName table.dataElement.target 'Stored' }}>();
    const [isNextButtonEnabled, setIsNextButtonEnabled] = useState<boolean>(true);
    const [page, setPage] = useState<number>(0);
    const [filters, setFilters] = useState<Filter[]>([]);
    const [queryCustomizer, setQueryCustomizer] = useState<{{ classDataName table.dataElement.target 'QueryCustomizer' }}>({
        _mask: '{{ table.formattedMask }}',
        _seek: {
            limit: {{ calculateTablePageLimit tablePageLimit }} + 1,
        },
        _orderBy: [
            {
                attribute: sortModel[0].field,
                descending: sortModel[0].sort === 'desc',
            },
        ],
        ...mapAllFiltersToQueryCustomizerProperties(
            filters,
            {{# each table.filters as |filter| }}
                '{{ filter.attributeType.name }}',
            {{/ each }}
        ),
    });

    {{# if debugPrint }}// include: actor/src/fragments/table/hook-variables.fragment.hbs{{/ if }}
    {{> actor/src/fragments/table/hook-variables.fragment.hbs table=table }}

    {{# each (getFilteredTableActions table) as |action| }}
        {{# if action.isFilterAction }}
            const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}(setFilters, setPage, setQueryCustomizer, openFilterDialog);
        {{ else }}
            const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}();
        {{/ if }}
    {{/ each }}

    const filterOptions: FilterOption[] = [
        {{# each table.filters as |filter| }}
            {{# if debugPrint }}// include: actor/src/fragments/table/filter-option.fragment.hbs{{/ if }}
            {{> actor/src/fragments/table/filter-option.fragment.hbs filter=filter application=application }}
        {{/ each }}
    ];

    const rowActions: TableRowAction<{{ classDataName table.dataElement.target 'Stored' }}>[] = [
        {{# each table.rowActions as |action| }}
            {{# if action.isRemoveAction }}
                {
                    id: '{{ createId action }}',
                    label: t('judo.pages.table.remove', { defaultValue: 'Remove' }) as string,
                    icon: <MdiIcon path="{{ action.icon.name }}" />,
                    action: async (row: {{ classDataName table.dataElement.target 'Stored' }}) => {{ actionFunctionName action }}({{# unless page.dataElement.isAccess }}ownerData, {{/ unless }}row, () => fetchData()),
                },
            {{/ if }}
            {{# if action.isDeleteAction }}
                {
                    id: '{{ createId action }}',
                    label: t('judo.pages.table.delete', { defaultValue: 'Delete' }) as string,
                    icon: <MdiIcon path="{{ action.icon.name }}" />,
                    action: async (row: {{ classDataName table.dataElement.target 'Stored' }}) => {{ actionFunctionName action }}({{# unless page.dataElement.isAccess }}ownerData, {{/ unless }}row, () => fetchData()),
                    disabled: (row: {{ classDataName table.dataElement.target 'Stored' }}) => !row.__deleteable,
                },
            {{/ if }}
            {{# if action.isCallOperationAction }}
                {
                    id: '{{ createId action }}',
                    label: t('{{ idToTranslationKey action.fQName application }}', { defaultValue: '{{ action.label }}' }) as string,
                    icon: <MdiIcon path="{{ action.icon.name }}" />,
                    action: async (row: {{ classDataName table.dataElement.target 'Stored' }}) => {{ actionFunctionName action }} ({{# if action.operation.isMapped }}row, {{/ if }}() => fetchData()),
                },
            {{/ if }}
        {{/ each }}
    ];

    function handleSortModelChange (newModel: GridSortModel) {
        setPage(0);
        setSortModel(newModel);

        const { field, sort } = newModel[0];

        setQueryCustomizer((prevQueryCustomizer) => {
            return {
                ...prevQueryCustomizer,
                _orderBy: [{ attribute: field, descending: sort === 'desc' }],
            };
        });
    }

    async function handlePageChange (isNext: boolean) {
        setQueryCustomizer((prevQueryCustomizer) => {
            return {
                ...prevQueryCustomizer,
                _seek: {
                    limit: isNext ? {{ calculateTablePageLimit tablePageLimit }} + 1 : {{ calculateTablePageLimit tablePageLimit }},
                    reverse: !isNext,
                    lastItem: isNext ? lastItem : firstItem,
                },
            };
        });

        setIsNextButtonEnabled(!isNext);
    }

    async function fetchData() {
        setIsOwnerLoading(true);

        try {
            {{# unless page.dataElement.isAccess }}
                const res = await {{ classServiceName table.dataElement.owner }}Impl.get{{ ucFirst table.dataElement.name }}(
                    ownerData,
                    processQueryCustomizer(queryCustomizer),
                );
            {{ else }}
                const res = await {{ dataElementRelationName page.dataElement }}Impl.list{{ ucFirst page.dataElement.name }}(processQueryCustomizer(queryCustomizer));
            {{/ unless }}

            if (res.length > {{ calculateTablePageLimit tablePageLimit }}) {
                setIsNextButtonEnabled(true);
                res.pop();
            } else if (queryCustomizer._seek?.limit === {{ calculateTablePageLimit tablePageLimit }} + 1) {
                setIsNextButtonEnabled(false);
            }

            setData(res);
            setFirstItem(res[0]);
            setLastItem(res[res.length - 1]);
            setRowCount(res.length || 0);
        } catch (error) {
            handleFetchError(error);
        } finally {
            setIsOwnerLoading(false);
        }
    }

    useImperativeHandle(ref, () => ({
        fetchData,
    }));

    useEffect(() => {
        fetchData();
    }, [queryCustomizer]);

    return (
        <DataGrid
            { ...baseTableConfig }
            sx={ {
                // overflow: 'hidden',
                display: 'grid',
            } }
            getRowId={(row: { __identifier: string }) => row.__identifier}
            loading={ isOwnerLoading }
            rows={ data }
            getRowClassName={() => "data-grid-row"}
            getCellClassName={() => "data-grid-cell"}
            columns={[ ...{{ table.dataElement.name }}Columns, ...columnsActionCalculator('{{ createId table.dataElement }}', rowActions, { shownActions: 2 }) ]}
            disableRowSelectionOnClick
            {{# each table.rowActions as |action| }}
                {{# if action.isViewAction }}
                    onRowClick={ (params: GridRowParams<{{ classDataName table.dataElement.target 'Stored' }}>) => {{ actionFunctionName action }}({{# unless page.dataElement.isAccess }}ownerData, {{/ unless }}params.row) }
                {{/ if }}
            {{/ each }}
            sortModel={ sortModel }
            onSortModelChange={ handleSortModelChange }
            components={ {
                Toolbar: () => (
                    <GridToolbarContainer>
                        {{# each (getFilteredTableActions table) as |action| }}
                            {{# if action.isFilterAction }}
                                <Button
                                    id="{{ createId action }}"
                                    variant="text"
                                    onClick={ () => {
                                        {{ actionFunctionName action }}('{{ createId action }}-filter', filterOptions, filters);
                                    } }
                                    disabled={isOwnerLoading}
                                >
                                    <MdiIcon path="filter" />
                                    {t('judo.pages.table.set-filters', { defaultValue: 'Set filters' }) + (filters.length !== 0 ? ' (' + filters.length + ')' : '')}
                                </Button>
                            {{/ if }}
                        {{/ each }}
                        <div>{/* Placeholder */}</div>
                    </GridToolbarContainer>
                ),
                Pagination: () => (
                    <CustomTablePagination
                        pageChange={handlePageChange}
                        isNextButtonEnabled={isNextButtonEnabled}
                        page={page}
                        setPage={setPage}
                        rowPerPage={ {{ calculateTablePageLimit tablePageLimit }} }
                    />
                ),
            } }
        />
    );
});
