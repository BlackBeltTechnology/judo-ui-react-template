import {
    {{# each (getApiImportsForReferenceType table.dataElement) as |imp| }}
        {{ imp }},
    {{/ each }}
} from '~/generated/data-api';
import {
    {{# unless table.dataElement.isAccess }}
        {{ classServiceName table.dataElement.owner }}Impl,
        {{# neq (classServiceName table.dataElement.owner) (classServiceName table.dataElement.target) }}
            {{ classServiceName table.dataElement.target }}Impl,
        {{/ neq }}
    {{ else }}
        {{ dataElementRelationName table.dataElement }}Impl,
    {{/ unless }}
} from '~/generated/data-axios';
{{# if (tableHasActionsToImport table) }}
    import {
        {{# each (getFilteredTableActions table) as |action| }}
            {{ actionFunctionHookName action }},
        {{/ each }}
    } from '../actions';
{{/ if }}
import { GridLogicOperator } from '@mui/x-data-grid{{ getMUIDataGridPlanSuffix }}';

export const {{ getCustomizationComponentInterfaceKey table }} = '{{ getCustomizationComponentInterface table }}';

export interface {{ tableComponentName table }}Props {
    {{# unless table.dataElement.isAccess }}
        ownerData: JudoIdentifiable<{{ classDataName table.dataElement.owner '' }}>
    {{/ unless }}
    isOwnerLoading: boolean;
    setIsOwnerLoading: (value: boolean) => void;
}

export const {{ tableComponentName table }} = forwardRef<RefreshableTable, {{ tableComponentName table }}Props>((props, ref) => {
    const { getItemParsedWithDefault, setItemStringified } = useDataStore('sessionStorage');
    const { isOwnerLoading, setIsOwnerLoading{{# unless table.dataElement.isAccess }}, ownerData{{/ unless }} } = props;
    {{# unless table.dataElement.isAccess }}
    const { sub: __identifier } = decodeToken<{ sub: string }>(ownerData.__signedIdentifier)!;
    {{/ unless }}
    const { t } = useTranslation();
    const { openFilterDialog } = useFilterDialog();
    const { openRangeDialog } = useRangeDialog();
    const { downloadFile, extractFileNameFromToken, uploadFile } = fileHandling();
    const { locale: l10nLocale } = useL10N();
    const handleFetchError = useErrorHandler(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Fetch))`);
    {{# if (stringValueIsTrue useTableRowHighlighting) }}
    const { service: rowHighlightingHook } = useTrackService<TableRowHighlightingHook<{{ classDataName table.dataElement.target 'Stored' }}>>(`(&(${OBJECTCLASS}=${TABLE_ROW_HIGHLIGHTING_HOOK_INTERFACE_KEY})(component=${ {{~ getCustomizationComponentInterfaceKey table ~}} }))`);
    const rowHighlighting = rowHighlightingHook && rowHighlightingHook();
    const rowStylings: RowStylerConfigured<{{ classDataName table.dataElement.target 'Stored' }}>[] = useMemo(() => {
        return rowHighlighting ? rowHighlighting() : [];
    }, [rowHighlighting]);
    {{/ if }}
    const openCRUDDialog = useCRUDDialog();

    const [data, setData] = useState<GridRowModel<{{ classDataName table.dataElement.target 'Stored' }}>[]>([]);
    const [rowCount, setRowCount] = useState<number>(0);
    const [sortModel, setSortModel] = useState<GridSortModel>({{{ getDefaultSortParamsForTable table }}});
    const filterModelKey = `{{ createId table }}{{# unless table.dataElement.isAccess }}-${__identifier}{{/ unless }}-filterModel`;
    const filtersKey = `{{ createId table }}{{# unless table.dataElement.isAccess }}-${__identifier}{{/ unless }}-filters`;
    const [filterModel, setFilterModel] = useState<GridFilterModel>(getItemParsedWithDefault(filterModelKey, { items: [] }));
    const [filters, setFilters] = useState<Filter[]>(getItemParsedWithDefault(filtersKey, []));
    const [lastItem, setLastItem] = useState<{{ classDataName table.dataElement.target 'Stored' }}>();
    const [firstItem, setFirstItem] = useState<{{ classDataName table.dataElement.target 'Stored' }}>();
    const [isNextButtonEnabled, setIsNextButtonEnabled] = useState<boolean>(true);
    const [page, setPage] = useState<number>(0);
    const [queryCustomizer, setQueryCustomizer] = useState<{{ classDataName table.dataElement.target 'QueryCustomizer' }}>({
        _mask: '{{ table.formattedMask }}',
        _seek: {
            limit: {{ calculateTablePageLimit table }} + 1,
        },
        _orderBy: sortModel.length ? [
            {
                attribute: sortModel[0].field,
                descending: sortModel[0].sort === 'desc',
            },
        ] : [],
        ...mapAllFiltersToQueryCustomizerProperties(filters),
    });
    {{# if isDebugPrint }}// include: actor/src/fragments/table/row-selection.fragment.hbs{{/ if }}
    {{> actor/src/fragments/table/row-selection.fragment.hbs table=table }}

    {{# unless table.dataElement.isAccess }}
    useEffect(() => {
        setFilters(getItemParsedWithDefault(`{{ createId table }}-${__identifier}-filters`, [...filters]));
    }, [ownerData]);
    {{/ unless }}
    useEffect(() => {
        setItemStringified(filtersKey, filters);
    }, [filters]);
    useEffect(() => {
        setItemStringified(filterModelKey, filterModel);
    }, [filterModel]);

    {{# if isDebugPrint }}// include: actor/src/fragments/table/hook-variables.fragment.hbs{{/ if }}
    {{> actor/src/fragments/table/hook-variables.fragment.hbs table=table }}

    {{# each (getFilteredTableActions table) as |action| }}
        {{# if action.isFilterAction }}
            const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}(setFilters, setPage, setQueryCustomizer, openFilterDialog, {{ calculateTablePageLimit table }});
        {{ else }}
            const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}();
        {{/ if }}
    {{/ each }}

    {{# if (isTableFilterable table) }}
        const filterOptions: FilterOption[] = [
            {{# each table.filters as |filter| }}
                {{# if isDebugPrint }}// include: actor/src/fragments/table/filter-option.fragment.hbs{{/ if }}
                {{> actor/src/fragments/table/filter-option.fragment.hbs filter=filter application=application }}
            {{/ each }}
        ];
    {{/ if }}

    const rowActions: TableRowAction<{{ classDataName table.dataElement.target 'Stored' }}>[] = [
        {{# each table.rowActions as |action| }}
            {{# if action.isRemoveAction }}
                {
                    id: '{{ createId action }}',
                    label: t('judo.pages.table.remove', { defaultValue: 'Remove' }) as string,
                    icon: <MdiIcon path="{{ action.icon.name }}" />,
                    action: async (row: {{ classDataName table.dataElement.target 'Stored' }}) => {{ actionFunctionName action }}({{# unless table.dataElement.isAccess }}ownerData, {{/ unless }}row, () => fetchData()),
                },
            {{/ if }}
            {{# if action.isDeleteAction }}
                {
                    id: '{{ createId action }}',
                    label: t('judo.pages.table.delete', { defaultValue: 'Delete' }) as string,
                    icon: <MdiIcon path="{{ action.icon.name }}" />,
                    action: async (row: {{ classDataName table.dataElement.target 'Stored' }}) => {{ actionFunctionName action }}({{# unless table.dataElement.isAccess }}ownerData, {{/ unless }}row, () => fetchData()),
                    disabled: (row: {{ classDataName table.dataElement.target 'Stored' }}) => !row.__deleteable,
                },
            {{/ if }}
            {{# if action.isCallOperationAction }}
                {
                    id: '{{ createId action }}',
                    label: t('{{ getTranslationKeyForAction action }}', { defaultValue: '{{ action.label }}' }) as string,
                    icon: <MdiIcon path="{{ action.icon.name }}" />,
                    action: async (row: {{ classDataName table.dataElement.target 'Stored' }}) => {{ actionFunctionName action }} ({{# if action.operation.isMapped }}row, {{/ if }}() => fetchData()),
                },
            {{/ if }}
        {{/ each }}
    ];

    {{# if (tableHasDeleteAction table) }}
      const bulkDeleteSelected = useCallback(() => {
        openCRUDDialog<{{ classDataName table.dataElement.target 'Stored' }}>({
          dialogTitle: t('judo.dialogs.crud-bulk.delete.title', { defaultValue: 'Delete selected items' }),
          {{# with (getFirstTitleColumnForTable table) as |column| }}
            itemTitleFn: (item) => item.{{ column.attributeType.name }}!,
          {{ else }}
            itemTitleFn: (item) => t('judo.placeholder', { defaultValue: 'placeholder' }) as string,
          {{/ with }}
          selectedItems: selectedRows.current,
          action: async (item, successHandler: () => void, errorHandler: (error: any) => void) => {
            {{# each table.rowActions as |action| }}
              {{# if action.isDeleteAction }}
                await {{ actionFunctionName action }}({{# unless table.dataElement.isAccess }}ownerData, {{/ unless }}item, successHandler, errorHandler, true);
              {{/ if }}
            {{/ each }}
          },
          onClose: (needsRefresh) => {
            if (needsRefresh) {
              fetchData();
              setSelectionModel([]); // not resetting on fetchData because refreshes would always remove selections...
            }
          },
        });
      }, []);
      const isBulkDeleteAvailable: () => boolean = useCallback(()=> {
        // every row has the same `__deleteable` flag
        return !!selectionModel.length && !{{ boolValue table.dataElement.isReadOnly }} && !!data[0]?.__deleteable;
      }, [data, selectionModel]);
    {{/ if }}
    {{# if (tableHasRemoveAction table) }}
      const bulkRemoveSelected = useCallback(() => {
        openCRUDDialog<{{ classDataName table.dataElement.target 'Stored' }}>({
          dialogTitle: t('judo.dialogs.crud-bulk.remove.title', { defaultValue: 'Remove selected items' }),
          {{# with (getFirstTitleColumnForTable table) as |column| }}
            itemTitleFn: (item) => item.{{ column.attributeType.name }}!,
          {{ else }}
            itemTitleFn: (item) => t('judo.placeholder', { defaultValue: 'placeholder' }) as string,
          {{/ with }}
          selectedItems: selectedRows.current,
          action: async (item, successHandler: () => void, errorHandler: (error: any) => void) => {
            {{# each table.rowActions as |action| }}
              {{# if action.isRemoveAction }}
                await {{ actionFunctionName action }}({{# unless table.dataElement.isAccess }}ownerData, {{/ unless }}item, successHandler, errorHandler);
              {{/ if }}
            {{/ each }}
          },
          onClose: (needsRefresh) => {
            if (needsRefresh) {
              fetchData();
              setSelectionModel([]); // not resetting on fetchData because refreshes would always remove selections...
            }
          },
        });
      }, []);
      const isBulkRemoveAvailable: () => boolean = useCallback(()=> {
        return !!selectionModel.length;
      }, [selectionModel]);
    {{/ if }}
    {{# each (getBulkOperationActionsForTable table) as |action| }}
      const {{ actionFunctionName action }}BulkCall = async (item: {{ classDataName table.dataElement.target 'Stored' }}, successHandler: () => void, errorHandler: (error: any) => void) => {
        await {{ actionFunctionName action }}(item, successHandler, errorHandler, true);
      }
    {{/ each }}
    {{# if (tableHasBulkOperations table) }}
      const bulkCallOperation = useCallback((title: string, actionName: string, action: (item: {{ classDataName table.dataElement.target 'Stored' }}, successHandler: () => void, errorHandler: (error: any) => void) => Promise<void>) => {
        openCRUDDialog<{{ classDataName table.dataElement.target 'Stored' }}>({
          dialogTitle: title,
          {{# with (getFirstTitleColumnForTable table) as |column| }}
            itemTitleFn: (item) => item.{{ column.attributeType.name }}!,
          {{ else }}
            itemTitleFn: (item) => t('judo.placeholder', { defaultValue: 'placeholder' }) as string,
          {{/ with }}
          selectedItems: selectedRows.current,
          action: action,
          onClose: (needsRefresh) => {
            if (needsRefresh) {
              fetchData();
              setSelectionModel([]); // not resetting on fetchData because refreshes would always remove selections...
            }
          },
          faultPrefix: `{{ classServiceTypeName table.dataElement.target }}.${actionName}`,
        });
      }, []);

      const isBulkOperationAvailable: () => boolean = useCallback(() => {
        return !!selectionModel.length;
      }, [selectionModel]);
    {{/ if }}

    {{# if (stringValueIsTrue useTableContextMenus) }}
        const contextMenuRef = useRef<ContextMenuApi>(null);

        const handleContextMenu = (event: MouseEvent<HTMLElement>) => {
            contextMenuRef.current?.handleContextMenu(event);
        };
    {{/ if }}

    {{# if isUseInlineColumnFilters }}
    function handleFilterModelChange (newModel: GridFilterModel) {
        setFilterModel(newModel);

        if (newModel.items.every(i => i.value !== undefined)) {
            const newFilters: Filter[] = mapFilterModelToFilters(newModel, filterOptions);

            if (Array.isArray(newFilters)) {
                handleFiltersChange(newFilters);
            }
        }
    }
    {{/ if }}

    const handleFiltersChange = (newFilters: Filter[]) => {
        setPage(0);
        setFilters(newFilters);

        setQueryCustomizer((prevQueryCustomizer: {{ classDataName table.dataElement.target 'QueryCustomizer' }}) => {
            // remove previous filter values, so that we can always start with a clean slate
            for (const name of {{ table.dataElement.name }}Columns.map(c => c.field)) {
                delete (prevQueryCustomizer as any)[name];
            }
            return {
                ...prevQueryCustomizer,
                _seek: {
                    limit: {{ calculateTablePageLimit table }} + 1,
                },
                ...mapAllFiltersToQueryCustomizerProperties(newFilters),
            };
        });
    };

    function handleSortModelChange (newModel: GridSortModel) {
        setPage(0);
        setSortModel(newModel);

        const _orderBy = newModel.filter(m => m.sort).map(m => ({
            attribute: m.field,
            descending: m.sort === 'desc',
        }));

        setQueryCustomizer((prevQueryCustomizer) => {
            const strippedQueryCustomizer: {{ classDataName table.dataElement.target 'QueryCustomizer' }} = {
              ...prevQueryCustomizer
            };
            if (!!strippedQueryCustomizer._seek) {
              delete strippedQueryCustomizer._seek.lastItem;
            }
            return {
                ...strippedQueryCustomizer,
                _orderBy,
            };
        });
    }

    async function handlePageChange (isNext: boolean) {
        setQueryCustomizer((prevQueryCustomizer) => {
            return {
                ...prevQueryCustomizer,
                _seek: {
                    limit: isNext ? {{ calculateTablePageLimit table }} + 1 : {{ calculateTablePageLimit table }},
                    reverse: !isNext,
                    lastItem: isNext ? lastItem : firstItem,
                },
            };
        });

        setIsNextButtonEnabled(!isNext);
    }

    async function fetchData() {
        setIsOwnerLoading(true);

        try {
            {{# unless table.dataElement.isAccess }}
                const res = await {{ classServiceName table.dataElement.owner }}Impl.get{{ ucFirst table.dataElement.name }}(
                    ownerData,
                    processQueryCustomizer(queryCustomizer),
                );
            {{ else }}
                const res = await {{ dataElementRelationName table.dataElement }}Impl.list{{ ucFirst table.dataElement.name }}(processQueryCustomizer(queryCustomizer));
            {{/ unless }}

            if (res.length > {{ calculateTablePageLimit table }}) {
                setIsNextButtonEnabled(true);
                res.pop();
            } else if (queryCustomizer._seek?.limit === {{ calculateTablePageLimit table }} + 1) {
                setIsNextButtonEnabled(false);
            }

            setData(res);
            setFirstItem(res[0]);
            setLastItem(res[res.length - 1]);
            setRowCount(res.length || 0);
        } catch (error) {
            handleFetchError(error);
        } finally {
            setIsOwnerLoading(false);
        }
    }

    useImperativeHandle(ref, () => ({
        fetchData,
    }));

    useEffect(() => {
        fetchData();
    }, [queryCustomizer]);

    return (
        <>
            <StripedDataGrid
                { ...baseTableConfig }
                {{# if isMUILicensePlanPro }}
                    initialState={ { pinnedColumns: { right: ['actions'] } } }
                {{/ if }}
                pageSizeOptions={[{{ calculateTablePageLimit table }}]}
                sx={ {
                    // overflow: 'hidden',
                    display: 'grid',
                    {{# if (stringValueIsTrue useTableRowHighlighting) }}
                    ...transformRowStylings(rowStylings),
                    {{/ if }}
                } }
                slotProps={ {
                {{# if (stringValueIsTrue useTableContextMenus) }}
                  cell: {
                    onContextMenu: handleContextMenu,
                  },
                {{/ if }}
                  filterPanel: {
                    logicOperators: [GridLogicOperator.And],
                  },
                } }
                getRowId={(row: { __identifier: string }) => row.__identifier}
                loading={ isOwnerLoading }
                rows={ data }
                getRowClassName={ (params: GridRowClassNameParams) => {
                    {{# if (stringValueIsTrue useTableRowHighlighting) }}
                        const customStyle = rowStylings.find(r => r.condition(params));
                        if (customStyle) {
                            return customStyle.name;
                        }
                    {{/ if }}
                    return params.indexRelativeToCurrentPage % 2 === 0 ? 'even' : 'odd';
                } }
                columns={[ ...{{ table.dataElement.name }}Columns, ...columnsActionCalculator('{{ createId table.dataElement }}', rowActions, t, { shownActions: 2 }) ]}
                disableRowSelectionOnClick
                checkboxSelection
                rowSelectionModel={selectionModel}
                onRowSelectionModelChange={(newRowSelectionModel) => {
                  setSelectionModel(newRowSelectionModel);
                }}
                keepNonExistentRowsSelected
                {{# each table.rowActions as |action| }}
                    {{# if action.isViewAction }}
                        onRowClick={ (params: GridRowParams<{{ classDataName table.dataElement.target 'Stored' }}>) => {{ actionFunctionName action }}({{# unless table.dataElement.isAccess }}ownerData, {{/ unless }}params.row, () => fetchData()) }
                    {{/ if }}
                {{/ each }}
                sortModel={ sortModel }
                onSortModelChange={ handleSortModelChange }
                {{# if isUseInlineColumnFilters }}
                filterModel={filterModel}
                onFilterModelChange={handleFilterModelChange}
                {{/ if }}
                components={ {
                    Toolbar: () => (
                        <GridToolbarContainer>
                            {{# each (getFilteredTableActions table) as |action| }}
                                {{# if action.isFilterAction }}
                                    {{# unless isUseInlineColumnFilters }}
                                    <Button
                                        id="{{ createId action }}"
                                        startIcon={<MdiIcon path="filter" />}
                                        variant="text"
                                        onClick={ () => {
                                            {{ actionFunctionName action }}('{{ createId action }}-filter', filterOptions, filters);
                                        } }
                                        disabled={isOwnerLoading}
                                    >
                                        {t('judo.pages.table.set-filters', { defaultValue: 'Set filters' }) + (filters.length !== 0 ? ' (' + filters.length + ')' : '')}
                                    </Button>
                                    {{ else }}
                                        <GridToolbarFilterButton componentsProps={ { button: { variant: 'text' } } }  />
                                    {{/ unless }}
                                {{/ if }}
                            {{/ each }}
                            {{# if (tableHasRemoveAction table) }}
                                {isBulkRemoveAvailable() ? <Button
                                    disabled={isOwnerLoading}
                                    variant="text"
                                    startIcon={<MdiIcon path="link-off" />}
                                    onClick={bulkRemoveSelected}>
                                    {t('judo.pages.table.remove.selected', { defaultValue: 'Remove' })}
                                </Button> : null}
                            {{/ if }}
                            {{# if (tableHasDeleteAction table) }}
                                {isBulkDeleteAvailable() ? <Button
                                    disabled={isOwnerLoading}
                                    variant="text"
                                    startIcon={<MdiIcon path="delete-forever" />}
                                    onClick={bulkDeleteSelected}>
                                    {t('judo.pages.table.delete.selected', { defaultValue: 'Delete' })}
                                </Button> : null}
                            {{/ if }}
                            {{# each (getBulkOperationActionsForTable table) as |bulkOp| }}
                                {isBulkOperationAvailable() ? <Button
                                    disabled={ isOwnerLoading{{# if bulkOp.enabledBy }} || selectedRows.current.some(r => !r.{{ bulkOp.enabledBy.name }}){{/ if }} }
                                    variant="text"
                                    {{# if bulkOp.icon }}
                                    startIcon={<MdiIcon path="{{ bulkOp.icon.name }}" />}
                                    {{/ if }}
                                    onClick={() => bulkCallOperation(t('{{ getTranslationKeyForAction bulkOp }}', { defaultValue: '{{ bulkOp.label }}' }), '{{ bulkOp.dataElement.name }}', {{ actionFunctionName bulkOp }}BulkCall)}>
                                    {t('{{ getTranslationKeyForAction bulkOp }}', { defaultValue: '{{ bulkOp.label }}' })}
                                </Button> : null}
                            {{/ each }}
                            <div>{/* Placeholder */}</div>
                        </GridToolbarContainer>
                    ),
                    Pagination: () => (
                        <CustomTablePagination
                            pageChange={handlePageChange}
                            isNextButtonEnabled={isNextButtonEnabled}
                            page={page}
                            setPage={setPage}
                            rowPerPage={ {{ calculateTablePageLimit table }} }
                        />
                    ),
                } }
            />
            {{# if (stringValueIsTrue useTableRowHighlighting) }}
                <RowHighlightLegend rowStylings={rowStylings} />
            {{/ if }}
            {{# if (stringValueIsTrue useTableContextMenus) }}
                <ContextMenu
                    ref={contextMenuRef}
                    data={data}
                    filters={filters}
                    filterOptions={filterOptions}
                    columns={ {{ table.dataElement.name }}Columns }
                    onFilterByCell={ (filter: Filter) => {
                        {{# if isUseInlineColumnFilters }}
                            handleFilterModelChange({
                                ...filterModel,
                                items: [...filterModel.items, mapFilterToFilterModel(filter)],
                            });
                        {{ else }}
                            handleFiltersChange([...filters, filter]);
                        {{/ if }}
                    } }
                    onExcludeByCell={ (filter: Filter) => {
                        {{# if isUseInlineColumnFilters }}
                            handleFilterModelChange({
                                ...filterModel,
                                items: [...filterModel.items, mapFilterToFilterModel(filter)],
                            });
                        {{ else }}
                            handleFiltersChange([...filters, filter]);
                        {{/ if }}
                    } }
                />
            {{/ if }}
        </>
    );
});
