return async function {{ actionFunctionName action }} ({{# if action.operation.isMapped }}owner: {{ classDataName action.dataElement.owner 'Stored' }}, {{/ if }}successCallback: () => void) {
    {{# if action.operation.input }}
        {{# with action.inputParameterPage.originalPageContainer.tables.[0] as |table| }}
            const columns: GridColDef<{{ classDataName action.inputParameterPage.dataElement.target 'Stored' }}>[] = [
                {{# each table.columns as |column| }}
                    {
                        ...baseColumnConfig,
                        field: '{{ column.attributeType.name }}',
                        headerName: t('{{ getTranslationKeyForVisualElement column }}', { defaultValue: '{{ column.label }}' }) as string,
                        {{# if isDebugPrint }}// include: actor/src/fragments/relation/column.fragment.hbs{{/ if }}
                        {{> actor/src/fragments/relation/column.fragment.hbs column=column dataElement=table.dataElement name=table.name }}
                    },
                {{/ each }}
            ];

            const filterOptions: FilterOption[] = [
                {{# each table.filters as |filter| }}
                    {{# if isDebugPrint }}// include: actor/src/fragments/table/filter-option.fragment.hbs{{/ if }}
                    {{> actor/src/fragments/table/filter-option.fragment.hbs filter=filter application=application }}
                {{/ each }}
            ];

            const sortModel: GridSortModel = {{{ getDefaultSortParamsForTable table }}};

            const initialQueryCustomizer: {{ classDataName action.inputParameterPage.dataElement.target 'QueryCustomizer' }} = {
                _mask: '{{ table.formattedMaskForRange }}',
                _orderBy: sortModel.length ? [
                    {
                        attribute: sortModel[0].field,
                        descending: sortModel[0].sort === 'desc',
                    },
                ] : [],
            };

            const res = await openRangeDialog<{{ classDataName action.inputParameterPage.dataElement.target 'Stored' }}, {{ classDataName action.inputParameterPage.dataElement.target 'QueryCustomizer' }}>({
                id: '{{ createId action.inputParameterPage }}',
                columns,
                defaultSortField: sortModel[0],
                rangeCall: async (queryCustomizer) => await {{ classServiceName action.dataElement.owner }}Impl.getRangeFor{{ firstToUpper action.operation.name }}({{# if action.operation.isMapped }}owner{{ else }}undefined{{/ if }}, processQueryCustomizer(queryCustomizer)),
                single: true,
                alreadySelectedItems: '', // TODO: ???
                filterOptions,
                initialQueryCustomizer,
            });

            if (res === undefined) return;
        {{/ with }}

    {{ else }}
        {{# if (hasConfirmation action) }}
            // TODO: implement shiny MUI Dialog here
            const result = confirm(t('{{ getTranslationKeyForAction action }}.confirmation', { defaultValue: '{{ action.confirmationMessage }}' }) as string);

            if (!result) {
                return;
            }
        {{/ if }}
    {{/ if }}

    try {
        const result = await {{ classServiceName action.dataElement.owner }}Impl.{{ action.dataElement.name }}({{# if action.operation.isMapped }}owner{{/ if }}{{# if action.operation.input }}{{# if action.operation.isMapped }},{{/ if }}res.value as {{ classDataName action.inputParameterPage.dataElement.target 'Stored' }}{{/ if }});
        if (postHandler) {
            postHandler(successCallback{{# if action.outputParameterPage }}, result{{/ if }});
            return;
        }
        {{# if action.outputParameterPage }}
            if (result) {
                {{# unless (actionHasUnmappedOutputForm action) }}
                    {{# unless (pageShouldOpenInDialog action.outputParameterPage) }}
                        navigate(routeTo{{ pageName action.outputParameterPage }}(result.__signedIdentifier));
                    {{ else }}
                        createDialog({
                            {{# if (adjustDialogSize action.outputParameterPage) }}
                                fullWidth: true,
                                maxWidth: '{{ toLower action.outputParameterPage.dialogSize.name }}',
                            {{/ if }}
                            onClose: (event: object, reason: string) => {
                                if (reason !== 'backdropClick') {
                                    closeDialog();
                                }
                            },
                            children: (
                                <{{ pageName action.outputParameterPage }}
                                    successCallback={ () => {
                                        closeDialog();
                                    } }
                                    cancel={() => closeDialog()}
                                    entry={result}
                                />
                            ),
                        });
                    {{/ unless }}
                {{ else }}
                    createOutputDialog({
                        {{# if (adjustDialogSize action.outputParameterPage) }}
                            fullWidth: true,
                            maxWidth: '{{ toLower action.outputParameterPage.dialogSize.name }}',
                        {{/ if }}
                        onClose: (event: object, reason: string) => {
                            if (reason !== 'backdropClick') {
                                closeOutputDialog();
                            }
                        },
                        children: (
                            <{{ pageName action.outputParameterPage }} result={result} close={() => {
                               closeOutputDialog();
                               successCallback();
                            }} />
                        )
                    });
                {{/ unless }}
            } else {
                successCallback();
            }
        {{ else }}
            successCallback();
        {{/ if }}
        enqueueSnackbar(title, {
            variant: 'success',
            ...toastConfig.success,
        });
    } catch (error: any) {
        {{# if (hasCallOperationActionFaults action) }}
            if (isErrorOperationFault(error)) {
                const faultObjectKeys = Object.keys(error.response.data);
                const firstFaultKey = faultObjectKeys[0];
                const faultMappings: Record<string, {{# each action.operation.faults as |fault| }}{{ nameWithoutModel fault.target.name }}FaultHandler{{# unless @last}} | {{/ unless}}{{/ each }}> = {
                    {{# each action.operation.faults as |fault| }}
                        '{{ classServiceTypeName fault.target }}': (payload: {{ nameWithoutModel fault.target.name }}) => {
                            return {
                                {{# each fault.target.attributes as |attribute| }}
                                    [t('faults.{{ classServiceTypeName fault.target }}.{{ attribute.name }}', { defaultValue: '{{ attribute.name }}' })]: payload?.{{ attribute.name }},
                                {{/ each }}
                            };
                        },
                    {{/ each }}
                };

                createErrorDialog({
                    fullWidth: true,
                    maxWidth: 'md',
                    onClose: (event: object, reason: string) => {
                        if (reason !== 'backdropClick') {
                            closeErrorDialog();
                        }
                    },
                    children: (
                        <OperationFaultDialog
                            close={() => closeErrorDialog()}
                            faultObjectKey={firstFaultKey}
                            content={faultMappings[firstFaultKey](error.response.data[firstFaultKey])}
                        />
                    ),
                });
            } else {
                handleActionError(error{{# if action.operation.isMapped }}, undefined, owner{{/ if }});
            }
        {{ else }}
            handleActionError(error{{# if action.operation.isMapped }}, undefined, owner{{/ if }});
        {{/ if }}
    }
}
