{{> fragment.header.hbs }}
// Page name: {{ page.name }}
// Page owner name: {{ page.owner.name }}
// Page DataElement name: {{ page.dataElement.name }}
// Page DataElement owner name: {{ page.dataElement.owner.name }}

import { useEffect, useState, useCallback, FC } from 'react';
import { useTranslation } from 'react-i18next';
import { Box, Container, Grid, {{ getMuiMaterialImportsForPage page }} } from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { {{ getMuiDataGridImportsForPage page }} } from '@mui/x-data-grid';
{{# if (hasPageDateTimePickers page) }}
    import { {{ getMuiDateTimePickerImportsForPage page }} } from '@mui/x-date-pickers';
{{/ if }}
import { OBJECTCLASS } from '@pandino/pandino-api';
import { useSnackbar } from 'notistack';
import { ComponentProxy } from '@pandino/react-hooks';
import { useParams } from 'react-router-dom';
import {
    MdiIcon,
    ModeledTabs,
    PageHeader,
    DropdownButton,
    CustomBreadcrumb,
    useJudoNavigation,
} from '{{ relativePathFromPage page 'components' }}';
import type { Filter } from '{{ relativePathFromPage page 'components-api' }}';
import { columnsActionCalculator } from '{{ relativePathFromPage page 'components/table' }}';
import { useFilterDialog, useRangeDialog } from '{{ relativePathFromPage page 'components/dialog' }}';
import { AggregationInput, AssociationButton, BinaryInput, CollectionAssociationButton, TrinaryLogicCombobox } from '{{ relativePathFromPage page 'components/widgets' }}';
import {
    useErrorHandler,
    ERROR_PROCESSOR_HOOK_INTERFACE_KEY,
    fileHandling,
    mapAllFiltersToQueryCustomizerProperties,
    processQueryCustomizer,
    TableRowAction,
    uiDateToServiceDate,
    serviceDateToUiDate,
    uiTimeToServiceTime,
    serviceTimeToUiTime,
    stringToBooleanSelect,
    booleanToStringSelect,
} from '{{ relativePathFromPage page 'utilities' }}';
import { useConfirmationBeforeChange } from '{{ relativePathFromPage page 'hooks' }}';
import { baseTableConfig, toastConfig, dividerHeight } from '{{ relativePathFromPage page 'config' }}';
import { useL10N } from '{{ relativePathFromPage page 'l10n' }}/l10n-context';
import { CUSTOM_VISUAL_ELEMENT_INTERFACE_KEY, CustomFormVisualElementProps } from '{{ relativePathFromPage page 'custom' }}';
import {
    {{# each (getApiImportsForViewPage page) as |imp| }}
        {{ imp }},
    {{/ each }}
} from '{{ relativePathFromPage page 'generated/data-api' }}';
import {
    {{ dataElementRelationName page.dataElement }}Impl,
    {{ classServiceName page.dataElement.target }}Impl,
} from '{{ relativePathFromPage page 'generated/data-axios'}}';
import { JudoIdentifiable } from '@judo/data-api-common';
import { mainContainerPadding } from '{{ relativePathFromPage page 'theme' }}';
import { {{ pageName page }}PageActions } from './components/{{ pageName page }}PageActions';
import { use{{ pageName page }} } from './hooks/use{{ pageName page }}';
import {
{{# each (getUniquePageActions page) as |action| }}
    {{ actionFunctionHookName action page }},
{{/ each }}
} from './actions';

{{# each (getVisualElementsWithCustomImplementation page) as |ve| }}
    export const {{ getCustomizationComponentInterfaceKey ve }} = '{{ getCustomizationComponentInterface ve }}';
    export interface {{ getCustomizationComponentInterface ve }} extends FC<CustomFormVisualElementProps<{{ classDataName page.dataElement.target '' }}>> {}
{{/ each }}

/**
 * Name: {{ page.name }}
 * Is Access: {{ boolValue page.dataElement.isAccess }}
 * Is Dashboard: {{ boolValue page.isPageTypeDashboard }}
 * Type: View
 * Edit Mode Available: {{ boolValue page.dataElement.isUpdatable }}
 **/
export default function {{ pageName page }}() {
    const { t } = useTranslation();
    const { navigate, back } = useJudoNavigation();
    {{# if (isSingleAccessPage page) }}
        const [signedIdentifier, setSignedIdentifier] = useState<string>();
    {{ else }}
        const { signedIdentifier } = useParams();
    {{/ if }}

    const { openFilterDialog } = useFilterDialog();
    const { openRangeDialog } = useRangeDialog();
    const { downloadFile, extractFileNameFromToken, uploadFile } = fileHandling();
    const { locale: l10nLocale } = useL10N();
    const handleFetchError = useErrorHandler(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Fetch))`);
    {{# if page.dataElement.isUpdatable }}
        const handleUpdateError = useErrorHandler<{{ classDataName page.dataElement.target '' }}>(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Update)(component={{ pageName page }}))`);
    {{/ if }}
    {{# if page.dataElement.isDeletable }}
        const handleDeleteError = useErrorHandler<{{ classDataName page.dataElement.target '' }}>(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Delete)(component={{ pageName page }}))`);
    {{/ if }}
    const { enqueueSnackbar } = useSnackbar();
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [data, setData] = useState<{{ classDataName page.dataElement.target 'Stored' }}>({} as unknown as {{ classDataName page.dataElement.target 'Stored' }});
    const [payloadDiff, setPayloadDiff] = useState<Record<keyof {{ classDataName page.dataElement.target 'Stored' }}, any>>({} as unknown as Record<keyof {{ classDataName page.dataElement.target 'Stored' }}, any>);
    const storeDiff: (attributeName: keyof {{ classDataName page.dataElement.target 'Stored' }}, value: any) => void = useCallback((attributeName: keyof {{ classDataName page.dataElement.target 'Stored' }}, value: any) => {
        {{# if debugPrint }}// include: actor/src/fragments/page/store-diff-body.hbs{{/ if }}
        {{> actor/src/fragments/page/store-diff-body.hbs classType=page.dataElement.target }}
    }, [data]);
    const [editMode, setEditMode] = useState<boolean>(false);
    const [validation, setValidation] = useState<Map<keyof {{ classDataName page.dataElement.target '' }}, string>>(new Map<keyof {{ classDataName page.dataElement.target '' }}, string>());

    const {
        queryCustomizer,
        {{# each (getPageTables page) as |table| }}
            {{ table.dataElement.name }}Columns,
            {{ table.dataElement.name }}RangeFilterOptions,
            {{ table.dataElement.name }}InitialQueryCustomizer,
            {{ table.dataElement.name }}RowActions,
        {{/ each }}
        {{# each (getPageAssociationTables page) as |table| }}
            {{ table.dataElement.name }}FilterOptions,
        {{/ each }}
        {{# each (getPageWritableLinks page) as |link| }}
            {{ link.dataElement.name }}Columns,
            {{ link.dataElement.name }}RangeFilterOptions,
            {{ link.dataElement.name }}InitialQueryCustomizer,
        {{/ each }}
    } = use{{ pageName page }}(data, editMode, setEditMode, storeDiff, fetchData, {{# each (getPageAssociationTables page) as |table| }}
        fetch{{ firstToUpper table.dataElement.name }},
    {{/ each }});

    {{# each (getPageTables page) as |table| }}
        {{# if debugPrint }}// include: actor/src/fragments/page/sort-models.fragment.hbs{{/ if }}
        {{> actor/src/fragments/page/sort-models.fragment.hbs dataElement=table.dataElement defaultSortColumn=table.defaultSortColumn columns=table.columns }}
        {{# if table.dataElement.isAddable }}
            {{# unless table.dataElement.isMemberTypeTransient }}
                {{# if debugPrint }}// include: actor/src/fragments/action/range-call.fragment.hbs{{/ if }}
                {{> actor/src/fragments/action/range-call.fragment.hbs dataElement=table.dataElement }}
                {{# if debugPrint }}// include: actor/src/fragments/action/selection-model.fragment.hbs{{/ if }}
                {{> actor/src/fragments/action/selection-model.fragment.hbs dataElement=table.dataElement }}
            {{/ unless }}
        {{/ if }}
    {{/ each }}

    {{# each (getPageAssociationTables page) as |table| }}
        const [{{ table.dataElement.name }}Page, set{{ firstToUpper table.dataElement.name }}Page] = useState<number>(0);
        const [{{ table.dataElement.name }}Filters, set{{ firstToUpper table.dataElement.name }}Filters] = useState<Filter[]>([]);
        const [dataFor{{ firstToUpper table.dataElement.name }}, setDataFor{{ firstToUpper table.dataElement.name }}] = useState<Array<{{ classDataName table.dataElement.target 'Stored' }}>>([]);
        const [is{{ firstToUpper table.dataElement.name }}Loading, setIs{{ firstToUpper table.dataElement.name }}Loading] = useState<boolean>(false);
        const [queryCustomizerFor{{ firstToUpper table.dataElement.name }}, setQueryCustomizerFor{{ firstToUpper table.dataElement.name }}] = useState<{{ classDataName table.dataElement.target 'QueryCustomizer' }}>({
            _mask: '{{ table.formattedMask }}',
            _seek: {
                limit: {{ calculateTablePageLimit tablePageLimit }} + 1,
            },
            _orderBy: [
                {
                    attribute: {{ table.dataElement.name }}SortModel[0].field,
                    descending: {{ table.dataElement.name }}SortModel[0].sort === 'desc',
                },
            ],
            ...mapAllFiltersToQueryCustomizerProperties(
                {{ table.dataElement.name }}Filters,
                {{# each table.filters as |filter| }}
                    '{{ filter.attributeType.name }}',
                {{/ each }}
            ),
        });
    {{/ each }}

    {{# each (getUniquePageActions page) as |action| }}
        {{# if action.isFilterRelationAction }}
            const {{ actionFunctionName action page }} = {{ actionFunctionHookName action page }}(
                {{# with action.definedOn as |table| }}
                    set{{ firstToUpper table.dataElement.name }}Filters,
                    set{{ firstToUpper table.dataElement.name }}Page,
                    setQueryCustomizerFor{{ firstToUpper table.dataElement.name }},
                    openFilterDialog,
                {{/ with }}
            );
        {{ else }}
            const {{ actionFunctionName action page }} = {{ actionFunctionHookName action page }}();
        {{/if}}
    {{/ each }}

    {{# if (titleComesFromAttribute page) }}
        const title: string = data.{{ page.titleAttribute.name }} as string;
    {{ else }}
        const title: string = t('{{ idToTranslationKey page.fQName application }}', { defaultValue: '{{ page.label }}' });
    {{/ if }}

    {{# if debugPrint }}// include: actor/src/fragments/page/mapped-form-flags.hbs{{/ if }}
    {{> actor/src/fragments/page/mapped-form-flags.hbs }}

    useConfirmationBeforeChange(editMode, t('judo.form.navigation.confirmation', { defaultValue: 'You have potential unsaved changes in your form, are you sure you would like to navigate away?' }));

    {{# if (isSingleAccessPage page) }}
        async function init() {
            setIsLoading(true);

            try {
                const res = await {{ dataElementRelationName page.dataElement }}Impl.get{{ ucFirst page.dataElement.name }}('{}');

                setIsLoading(false);

                if (res?.__signedIdentifier) {
                    setData(res);
                    setSignedIdentifier(res.__signedIdentifier);
                } else {
                    {{# if page.dataElement.isCreatable }}
                        navigate('/{{ page.dataElement.name }}/create');
                    {{ else }}
                        navigate('*');
                    {{/ if }}

                }
            } catch (error) {
                handleFetchError(error);
            } finally {
                setIsLoading(false);
            }
        }

        useEffect(() => {
            init();
        }, []);
    {{/ if }}

    async function fetchData() {
        setIsLoading(true);

        try {
            const res = await {{ classServiceName page.dataElement.target }}Impl.refresh(
                { __signedIdentifier: signedIdentifier } as {{ classDataName page.dataElement.target 'Stored' }},
                processQueryCustomizer(queryCustomizer),
            );

            setData(res);
            setPayloadDiff({
                __identifier: res.__identifier,
                __signedIdentifier: res.__signedIdentifier,
                __version: res.__version,
                __entityType: res.__entityType,
            } as Record<keyof {{ classDataName page.dataElement.target 'Stored' }}, any>);
        } catch (error) {
            handleFetchError(error);
        } finally {
            setIsLoading(false);
        }
    }

    {{# each (getPageAssociationTables page) as |table| }}
        async function fetch{{ firstToUpper table.dataElement.name }}() {
            setIs{{ firstToUpper table.dataElement.name }}Loading(true);
            try {
                const res = await {{ classServiceName table.dataElement.owner }}Impl.get{{ firstToUpper table.dataElement.name }}(
                    { __signedIdentifier: signedIdentifier } as {{ classDataName page.dataElement.target 'Stored' }},
                    processQueryCustomizer(queryCustomizerFor{{ firstToUpper table.dataElement.name }}),
                );

                setDataFor{{ firstToUpper table.dataElement.name }}(res);
            } catch (error) {
                handleFetchError(error);
            } finally {
                setIs{{ firstToUpper table.dataElement.name }}Loading(false);
            }
        }
    {{/ each }}

    {{# each (getPageAssociationTables page) as |table| }}
        useEffect(() => {
            fetch{{ firstToUpper table.dataElement.name }}();
        }, [queryCustomizerFor{{ firstToUpper table.dataElement.name }}]);
    {{/ each }}

    {{# if page.dataElement.isUpdatable }}
        async function saveData() {
            setIsLoading(true);

            try {
                const res = await {{ classServiceName page.dataElement.target }}Impl.update(payloadDiff);

                if (res) {
                    enqueueSnackbar(t('judo.action.save.success', { defaultValue: 'Changes saved' }), {
                        variant: 'success',
                        ...toastConfig.success,
                    });
                    await fetchData();
                    setEditMode(false);
                }
            } catch (error) {
                handleUpdateError(error, { setValidation }, data);
            } finally {
                setIsLoading(false);
            }
        }
    {{/ if }}

    {{# if page.dataElement.isDeletable }}
        async function deleteData() {
            setIsLoading(true);

            try {
                await {{ classServiceName page.dataElement.target }}Impl.delete(data as {{ classDataName page.dataElement.target 'Stored' }});

                {{# if (isSingleAccessPage page) }}
                    navigate('/{{ page.dataElement.name }}/create');
                {{ else }}
                    back();
                {{/ if }}
            } catch (error) {
                handleDeleteError(error, undefined, data);
            } finally {
                setIsLoading(false);
            }
        }
    {{/ if }}

    {{# if (isSingleAccessPage page) }}
        useEffect(() => {
            if (signedIdentifier) {
                fetchData();
            }
        }, [signedIdentifier]);
    {{ else }}
        useEffect(() => {
            fetchData();
        }, []);
    {{/ if }}

    useEffect(() => {
        setValidation(new Map<keyof {{ classDataName page.dataElement.target '' }}, string>());
    }, [editMode]);

    return (
        <>
            {{# with (getDataContainerForPage page) as |rootChild| }}
                <PageHeader title={title}>
                    <{{ pageName page }}PageActions
                        data={data}
                        fetchData={fetchData}
                        editMode={editMode}
                        setEditMode={setEditMode}
                        isLoading={isLoading}
                        {{# if page.dataElement.isUpdatable }}saveData={saveData}{{/ if }}
                        {{# if page.dataElement.isDeletable }}deleteData={deleteData}{{/ if }}
                    />
                </PageHeader>
                <Container component="main" maxWidth="xl">
                    <Box sx={mainContainerPadding}>
                        <Grid container xs={12} sm={12} spacing={2} direction="{{# if rootChild.isDirectionHorizontal }}row{{ else }}column{{/ if }}" alignItems="{{ alignItems rootChild }}" justifyContent="{{ justifyContent rootChild }}">
                            {{# each rootChild.children as |child| }}
                                {{# if debugPrint }}{/* include: getWidgetTemplate() */}{{/ if }}
                                {{> (getWidgetTemplate child) }}
                            {{/ each }}
                        </Grid>
                    </Box>
                </Container>
            {{/ with }}
        </>
    );
}
