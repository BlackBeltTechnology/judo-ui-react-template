{{> fragment.header.hbs }}
// Page name: {{ page.name }}
// Page owner name: {{ page.owner.name }}
// Page DataElement name: {{ page.dataElement.name }}
// Page DataElement owner name: {{ page.dataElement.owner.name }}

{{# if isDebugPrint }}// include: actor/src/fragments/page/common-view-imports.fragment.hbs{{/ if }}
{{> actor/src/fragments/page/common-view-imports.fragment.hbs }}

import { IconButton, Dialog, DialogTitle, DialogContent, DialogContentText, DialogActions } from '@mui/material';
import { useConfirmDialog } from '~/components/dialog';
import {
    {{# each (getApiImportsForViewPage page) as |imp| }}
        {{ imp }},
    {{/ each }}
} from '~/generated/data-api';
import {
    {{ classServiceName page.dataElement.target }}Impl,
} from '~/generated/data-axios';

import {
    {{# each (getButtonActions page) as |action| }}
        {{ actionFunctionHookName action }},
    {{/ each }}
} from './actions';

{{# each page.originalPageContainer.links as |link| }}
    import { {{ linkComponentName link }} } from './components/{{ linkComponentName link }}';
{{/ each }}
{{# each page.originalPageContainer.tables as |table| }}
    import { {{ tableComponentName table }} } from './components/{{ tableComponentName table }}';
{{/ each }}

{{# each (getVisualElementsWithCustomImplementation page) as |ve| }}
    export const {{ getCustomizationComponentInterfaceKey ve }} = '{{ getCustomizationComponentInterface ve }}';
    export interface {{ getCustomizationComponentInterface ve }} extends FC<CustomFormVisualElementProps<{{ classDataName page.dataElement.target '' }}>> {}
{{/ each }}

export interface {{ pageName page }}Props {
    entry: {{ classTypeName page.dataElement.target }};
    successCallback: () => void;
    cancel: () => void;
}

export type {{ pageName page }}PostRefreshAction = (
    data: {{ classTypeName page.dataElement.target }},
    storeDiff: (attributeName: keyof {{ classTypeName page.dataElement.target }}, value: any) => void,
    setEditMode: Dispatch<SetStateAction<boolean>>,
    setValidation: Dispatch<SetStateAction<Map<keyof {{ classDataName page.dataElement.target '' }}, string>>>,
) => Promise<void>;

export const {{ camelCaseNameToInterfaceKey (pageName page) }}_POST_REFRESH_HOOK_INTERFACE_KEY = '{{ pageName page }}PostRefreshHook';
export type {{ pageName page }}PostRefreshHook = () => {{ pageName page }}PostRefreshAction;

/**
 * Name: {{ page.name }}
 * Is Access: {{ boolValue page.dataElement.isAccess }}
 * Type: View
 * Edit Mode Available: {{ boolValue page.dataElement.isUpdatable }}
 **/
export default function {{ pageName page }}(props: {{ pageName page }}Props) {
    const { entry, successCallback, cancel } = props;

    const { t } = useTranslation();
    const { navigate, back } = useJudoNavigation();
    const { downloadFile, extractFileNameFromToken, uploadFile } = fileHandling();
    const { locale: l10nLocale } = useL10N();
    const { enqueueSnackbar } = useSnackbar();
    const { openConfirmDialog } = useConfirmDialog();

    const handleFetchError = useErrorHandler(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Fetch))`);
    {{# if page.dataElement.isUpdatable }}
        const handleUpdateError = useErrorHandler<{{ classDataName page.dataElement.target '' }}>(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Update)(component={{ pageName page }}))`);
    {{/ if }}
    {{# if page.dataElement.isDeletable }}
        const handleDeleteError = useErrorHandler<{{ classDataName page.dataElement.target '' }}>(`(&(${OBJECTCLASS}=${ERROR_PROCESSOR_HOOK_INTERFACE_KEY})(operation=Delete)(component={{ pageName page }}))`);
    {{/ if }}

    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [refreshCounter, setRefreshCounter] = useState<number>(0);
    const [data, setData] = useState<{{ classTypeName page.dataElement.target }}>({} as unknown as {{ classTypeName page.dataElement.target }});
    const [payloadDiff, setPayloadDiff] = useState<Record<keyof {{ classTypeName page.dataElement.target }}, any>>({} as unknown as Record<keyof {{ classTypeName page.dataElement.target }}, any>);
    const [editMode, setEditMode] = useState<boolean>(false);
    const storeDiff: (attributeName: keyof {{ classTypeName page.dataElement.target }}, value: any) => void = useCallback((attributeName: keyof {{ classTypeName page.dataElement.target }}, value: any) => {
        {{# if isDebugPrint }}// include: actor/src/fragments/page/store-diff-body.hbs{{/ if }}
        {{> actor/src/fragments/page/store-diff-body.hbs classType=page.dataElement.target }}
    }, [data]);
    const [validation, setValidation] = useState<Map<keyof {{ classDataName page.dataElement.target '' }}, string>>(new Map<keyof {{ classDataName page.dataElement.target '' }}, string>());

    const queryCustomizer: {{ classDataName page.dataElement.target 'QueryCustomizer' }} = {
        _mask: '{{ page.formattedMask }}',
    };

    const { service: postRefreshHook } = useTrackService<{{ pageName page }}PostRefreshHook>(`(${OBJECTCLASS}=${ {{~ camelCaseNameToInterfaceKey (pageName page) }}_POST_REFRESH_HOOK_INTERFACE_KEY})`);
    const postRefreshAction: {{ pageName page }}PostRefreshAction | undefined = postRefreshHook && postRefreshHook();

    {{# each (getButtonActions page) as |action| }}
        const {{ actionFunctionName action }} = {{ actionFunctionHookName action }}();
    {{/ each }}

    {{# if (titleComesFromAttribute page) }}
        const title: string = data.{{ page.titleAttribute.name }} as string;
    {{ else }}
        const title: string = t('{{ getTranslationKeyForPage page }}', { defaultValue: '{{ page.label }}' });
    {{/ if }}

    {{# if page.dataElement.isUpdatable }}
        {{# if isDebugPrint }}// include: actor/src/fragments/page/mapped-form-flags.hbs{{/ if }}
        {{> actor/src/fragments/page/mapped-form-flags.hbs }}
    {{ else }}
        {{# if isDebugPrint }}// include: actor/src/fragments/page/unmapped-form-flags.hbs{{/ if }}
        {{> actor/src/fragments/page/unmapped-form-flags.hbs }}
    {{/ if }}

    useConfirmationBeforeChange(editMode, t('judo.form.navigation.confirmation', { defaultValue: 'You have potential unsaved changes in your form, are you sure you would like to navigate away?' }));

    {{# if page.dataElement.isRefreshable }}
    async function fetchData() {
        setIsLoading(true);

        try {
            const res = await {{ classServiceName page.dataElement.target }}Impl.refresh(
                { __signedIdentifier: entry.__signedIdentifier } as JudoIdentifiable<{{ classDataName page.dataElement.target '' }}>,
                processQueryCustomizer(queryCustomizer),
            );

            setData(res);
            setPayloadDiff({
                __identifier: res.__identifier,
                __signedIdentifier: res.__signedIdentifier,
                __version: res.__version,
                __entityType: res.__entityType,
            } as Record<keyof {{ classTypeName page.dataElement.target }}, any>);
            if (postRefreshAction) {
                try {
                    await postRefreshAction(res, storeDiff, setEditMode, setValidation);
                } catch(error) {
                    console.error(error);
                }
            }
        } catch (error) {
            handleFetchError(error);
        } finally {
            setIsLoading(false);
            setRefreshCounter((prevCounter) => prevCounter + 1);
        }
    }
    {{/ if }}

    {{# if page.dataElement.isUpdatable }}
        async function saveData() {
            {{# if (hasPageRequiredBy page) }}
                {{> actor/src/fragments/page/local-validate.fragment.hbs }}
            {{/ if }}
            setIsLoading(true);

            try {
                const res = await {{ classServiceName page.dataElement.target }}Impl.update(payloadDiff);

                if (res) {
                    enqueueSnackbar(t('judo.action.save.success', { defaultValue: 'Changes saved' }), {
                        variant: 'success',
                        ...toastConfig.success,
                    });
                    successCallback();
                }
            } catch (error) {
                handleUpdateError(error, { setValidation }, data);
            } finally {
                fetchData();
                setEditMode(false);
                setIsLoading(false);
            }
        }
    {{/ if }}

    {{# if page.dataElement.isDeletable }}
        async function deleteData() {
            setIsLoading(true);

            try {
                await {{ classServiceName page.dataElement.target }}Impl.delete(data);

                successCallback();
            } catch (error) {
                handleDeleteError(error, undefined, data);
            } finally {
                setIsLoading(false);
                cancel();
            }
        }
    {{/ if }}

    {{# if page.dataElement.isRefreshable }}
    useEffect(() => {
        fetchData();
    }, []);
    {{/ if }}

    useEffect(() => {
        setValidation(new Map<keyof {{ classDataName page.dataElement.target '' }}, string>());
    }, [editMode]);

    return (
        {{# with (getDataContainerForPage page) as |rootChild| }}
            <>
                <DialogTitle>
                    {title}
                    <IconButton
                        id="{{ pageName page }}-dialog-close"
                        aria-label="close"
                        onClick={ () => {
                          cancel();
                          if(!editMode) {
                           successCallback();
                          }
                        }}
                        sx={ {
                            position: 'absolute',
                            right: 8,
                            top: 8,
                            color: (theme) => theme.palette.grey[500],
                        } }
                    >
                        <MdiIcon path="close" />
                    </IconButton>
                </DialogTitle>
                <DialogContent dividers>
                    <Grid container spacing={2} direction="{{# if rootChild.isDirectionHorizontal }}row{{ else }}column{{/ if }}" alignItems="{{ alignItems rootChild }}" justifyContent="{{ justifyContent rootChild }}">
                        {{# each rootChild.children as |child| }}
                            {{# if isDebugPrint }}{/* include: getWidgetTemplate() */}{{/ if }}
                            {{> (getWidgetTemplate child) }}
                        {{/ each }}
                    </Grid>
                </DialogContent>
                <DialogActions>
                    <Grid className="page-action" item>
                        <Button
                          id="{{ pageName page }}-dialog-close"
                          variant="text"
                          onClick={ () => {
                            cancel();
                            if(!editMode) {
                             successCallback();
                            }
                          }}
                          disabled={isLoading}>
                            {t('judo.pages.close', { defaultValue: 'Close' })}
                        </Button>
                    </Grid>
                    {{# if isDebugPrint }}{/* include: actor/src/fragments/page/page-crud-actions.hbs */}{{/ if }}
                    {{> actor/src/fragments/page/page-crud-actions.hbs }}
                </DialogActions>
            </>
        {{/ with }}
    );
}
