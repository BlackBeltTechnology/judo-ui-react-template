{{> fragment.header.hbs }}

import { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import type { ElementType, MouseEvent, Dispatch, SetStateAction } from 'react';
import { useTranslation } from 'react-i18next';
import type { JudoIdentifiable } from '~/services/data-api/common';
import Box from '@mui/material/Box';
import IconButton from '@mui/material/IconButton';
import Button from '@mui/material/Button';
import ButtonGroup from '@mui/material/ButtonGroup';
import Typography from '@mui/material/Typography';
import { GridToolbarContainer, GridLogicOperator } from '@mui/x-data-grid{{ getMUIDataGridPlanSuffix }}';
import type {
  GridColDef,
  GridFilterModel,
  GridRowModel,
  GridRowId,
  GridRenderCellParams,
  GridRowSelectionModel,
  GridSortItem,
  GridSortModel,
  GridValueFormatterParams,
  GridRowClassNameParams,
  GridRowParams,
  GridValidRowModel,
} from '@mui/x-data-grid{{ getMUIDataGridPlanSuffix }}';
import { baseColumnConfig, baseTableConfig, basePageSizeOptions } from '~/config';
import { MdiIcon{{# unless table.isEager }}, CustomTablePagination{{/ unless }} } from '~/components';
import {
  {{# if (tableHasBooleanColumn table) }}booleanColumnOperators,{{/ if }}
  {{# if (tableHasDateColumn table) }}dateColumnOperators,{{/ if }}
  {{# if (tableHasDateTimeColumn table) }}dateTimeColumnOperators,{{/ if }}
  {{# if (tableHasNumericColumn table) }}numericColumnOperators,{{/ if }}
  {{# if (tableHasEnumerationColumn table) }}singleSelectColumnOperators,{{/ if }}
  {{# if isUseInlineColumnFilters }}stringColumnOperators,{{/ if }}
  columnsActionCalculator,
  ContextMenu,
  StripedDataGrid,
} from '~/components/table';
import { useConfirmDialog } from '~/components/dialog';
import type { ContextMenuApi } from '~/components/table/ContextMenu';
import type { Filter, FilterOption } from '~/components-api';
import { FilterType } from '~/components-api';
import type {
  {{ getTableAPIImports table container }}
} from '~/services/data-api';
{{# or (tableHasNumericColumn table) (tableHasDateColumn table) (tableHasDateTimeColumn table) }}
import { useL10N } from '~/l10n/l10n-context';
{{/ or }}
import {
  TABLE_COLUMN_CUSTOMIZER_HOOK_INTERFACE_KEY,
  {{# if container.isSelector }}
  isRowSelectable,
  {{ else }}
  getUpdatedRowsSelected,
  {{/ if }}
  {{# if table.isEager }}
  applyInMemoryFilters,
  {{/ if }}
  {{# if (tableHasBinaryColumn table) }}
  fileHandling,
  {{/ if }}
  {{# or (tableHasDateTimeColumn table) (tableHasDateColumn table) }}
  serviceDateToUiDate,
  {{/ or }}
  {{# if (tableHasTimeColumn table) }}
  serviceTimeToUiTime,
  {{/ if }}
  {{# if isUseInlineColumnFilters }}
  mapFilterModelToFilters,
  mapFilterToFilterModel,
  {{/ if }}
  mapAllFiltersToQueryCustomizerProperties,
  processQueryCustomizer,
  {{# unless table.isEager }}
  useErrorHandler,
  {{/ unless }}
} from '~/utilities';
import type { DialogResult, TableRowAction, ColumnCustomizerHook } from '~/utilities';
import { useDataStore } from '~/hooks';
import { OBJECTCLASS } from '@pandino/pandino-api';
{{# if (stringValueIsTrue useTableRowHighlighting) }}
import { useTrackService } from '@pandino/react-hooks';
import { RowHighlightLegend } from '~/components/table';
import { TABLE_ROW_HIGHLIGHTING_HOOK_INTERFACE_KEY, transformRowStylings } from '~/theme/table-row-highlighting';
import type { RowStylerConfigured, TableRowHighlightingHook } from '~/theme/table-row-highlighting';
{{/ if }}

export interface {{ componentName table }}ActionDefinitions {
{{# each table.tableActionDefinitions as |actionDefinition| }}
  {{# if actionDefinition.isFilterAction }}
    {{ simpleActionDefinitionName actionDefinition }}?: (id: string, filterOptions: FilterOption[], model?: GridFilterModel, filters?: Filter[]) => Promise<{ model?: GridFilterModel; filters?: Filter[] }>;
  {{ else }}
    {{# if actionDefinition.isRefreshAction }}
      {{ simpleActionDefinitionName actionDefinition }}?: (queryCustomizer: {{ classDataName (getReferenceClassType table) 'QueryCustomizer' }}) => Promise<{{ classDataName (getReferenceClassType table) 'Stored' }}[]>;
      get{{ firstToUpper table.relationName }}Mask?: () => string;
    {{ else }}
      {{# if actionDefinition.isSelectorRangeAction }}
        {{ simpleActionDefinitionName actionDefinition }}?: (queryCustomizer: {{ classDataName (getReferenceClassType table) 'QueryCustomizer' }}) => Promise<{{ classDataName (getReferenceClassType table) 'Stored' }}[]>;
      {{ else }}
        {{# if actionDefinition.isBulk }}
          {{ simpleActionDefinitionName actionDefinition }}?: (selectedRows: {{ classDataName (getReferenceClassType table) 'Stored' }}[]) => Promise<DialogResult<{{ classDataName (getReferenceClassType table) 'Stored' }}[]>>;
        {{ else }}
          {{ simpleActionDefinitionName actionDefinition }}?: ({{# if actionDefinition.targetType }}target: {{ classDataName actionDefinition.targetType 'Stored' }}{{/ if }}) => Promise<void>;
        {{/ if }}
      {{/ if }}
    {{/ if }}
  {{/ if }}
{{/ each }}
{{# each table.rowActionDefinitions as |actionDefinition| }}
  {{ simpleActionDefinitionName actionDefinition }}?: (row: {{ classDataName (getReferenceClassType table) 'Stored' }}{{# if actionDefinition.isBulkCapable }}, silentMode?: boolean{{/ if }}) => Promise<void>;
{{/ each }}
  {{ table.relationType.name }}AdditionalToolbarButtons?: (
    {{# with (getReferenceClassType table) as |classType| }}
    data: {{# if classType.isMapped }}{{ classDataName classType 'Stored' }}{{ else }}{{ classDataName classType '' }}{{/ if }}[],
    {{/ with }}
    isLoading: boolean,
    selectedRows: {{ classDataName (getReferenceClassType table) 'Stored' }}[],
    clearSelections: () => void
    {{# unless container.table }}
    , ownerData: {{ classDataName container.dataElement 'Stored' }}
    , editMode: boolean
    , isFormUpdateable: () => boolean
    {{/ unless }}
  ) => Record<string, ElementType>;
}

export interface {{ componentName table }}Props {
  uniqueId: string;
  actions: {{ componentName table }}ActionDefinitions;
  refreshCounter: number;
  isOwnerLoading?: boolean;
  validationError?: string;
  {{# if container.isSelector }}
  selectionDiff: {{ classDataName (getReferenceClassType table) 'Stored' }}[];
  setSelectionDiff: Dispatch<SetStateAction<{{ classDataName (getReferenceClassType table) 'Stored' }}[]>>;
  {{/ if }}
  {{# if container.isRelationSelector }}
  alreadySelected: {{ classDataName (getReferenceClassType table) 'Stored' }}[];
  {{/ if }}
  {{# unless container.table }}
  ownerData: {{ classDataName container.dataElement 'Stored' }};
  editMode: boolean;
  isFormUpdateable: () => boolean;
  {{/ unless }}
}

// XMIID: {{ getXMIID table }}
// Name: {{ table.name }}
export function {{ componentName table }}(props: {{ componentName table }}Props) {
  const {
    uniqueId,
    actions,
    refreshCounter,
    isOwnerLoading,
    validationError,
    {{# if container.isSelector }}
    selectionDiff,
    setSelectionDiff,
    {{/ if }}
    {{# if container.isRelationSelector }}
    alreadySelected,
    {{/ if }}
    {{# unless container.table }}
    ownerData,
    editMode,
    isFormUpdateable,
    {{/ unless }}
  } = props;
  const filterModelKey = `{{ createId table }}-${uniqueId}-filterModel`;
  const filtersKey = `{{ createId table }}-${uniqueId}-filters`;

  const { openConfirmDialog } = useConfirmDialog();
  const { getItemParsed, getItemParsedWithDefault, setItemStringified } = useDataStore('sessionStorage');
  {{# or (tableHasNumericColumn table) (tableHasDateColumn table) (tableHasDateTimeColumn table) }}
  const { locale: l10nLocale } = useL10N();
  {{/ or }}
  {{# if (tableHasBinaryColumn table) }}
  const { downloadFile, extractFileNameFromToken } = fileHandling();
  {{/ if }}
  const { t } = useTranslation();
  {{# unless table.isEager }}
  const handleError = useErrorHandler();
  {{/ unless }}

  {{# if (stringValueIsTrue useTableRowHighlighting) }}
  const { service: rowHighlightingHook } = useTrackService<TableRowHighlightingHook<{{ classDataName (getReferenceClassType table) 'Stored' }}>>(`(&(${OBJECTCLASS}=${TABLE_ROW_HIGHLIGHTING_HOOK_INTERFACE_KEY})(component={{~ componentName table ~}}))`);
  const rowHighlighting = rowHighlightingHook && rowHighlightingHook();
  const rowStylings: RowStylerConfigured<{{ classDataName (getReferenceClassType table) 'Stored' }}>[] = useMemo(() => {
    return rowHighlighting ? rowHighlighting() : [];
  }, [rowHighlighting]);
  {{/ if }}
  {{# each (customizableColumns table) as |column| }}
  const { service: {{ column.name }}ColumnCustomizerHook } = useTrackService<ColumnCustomizerHook<{{ classDataName (getReferenceClassType table) 'Stored' }}>>(`(&(${OBJECTCLASS}=${TABLE_COLUMN_CUSTOMIZER_HOOK_INTERFACE_KEY})(component={{~ componentName table ~}})(column={{ column.name }})`);
  const {{ column.name }}ColumnCustomizer = {{ column.name }}ColumnCustomizerHook && {{ column.name }}ColumnCustomizerHook();
  {{/ each }}

  const [isInternalLoading, setIsInternalLoading] = useState<boolean>(false);
  {{# with (getReferenceClassType table) as |classType| }}
  const [data, setData] = useState<GridRowModel<{{# if classType.isMapped }}{{ classDataName classType 'Stored' }}{{ else }}{{ classDataName classType '' }}{{/ if }}>[]>({{# if table.isSelectorTable }}[]{{ else }}{{# if table.isEager }}ownerData?.{{ table.dataElement.name }} || []{{ else }}[]{{/ if }}{{/ if }});
  {{/ with }}
  const [selectionModel, setSelectionModel] = useState<GridRowSelectionModel>([]);
  const [sortModel, setSortModel] = useState<GridSortModel>({{{ getDefaultSortParamsForTable table }}});
  const [filterModel, setFilterModel] = useState<GridFilterModel>(getItemParsedWithDefault(filterModelKey, { items: [] }));
  const [filters, setFilters] = useState<Filter[]>(getItemParsedWithDefault(filtersKey, []));
  const [rowsPerPage, setRowsPerPage] = useState<number>({{ calculateTablePageLimit table }});
  const [paginationModel, setPaginationModel] = useState({
    pageSize: rowsPerPage,
    page: 0,
  });
  const [queryCustomizer, setQueryCustomizer] = useState<{{ classDataName (getReferenceClassType table) 'QueryCustomizer' }}>({
    _mask: '{{ getMaskForTable table }}',
    _seek: {
      limit: rowsPerPage + 1,
    },
    _orderBy: sortModel.length ? [
      {
        attribute: sortModel[0].field,
        descending: sortModel[0].sort === 'desc',
      },
    ] : [],
    ...mapAllFiltersToQueryCustomizerProperties(filters),
  });
  {{# unless table.isEager }}
  const [page, setPage] = useState<number>(0);
  const [rowCount, setRowCount] = useState<number>(0);
  const [lastItem, setLastItem] = useState<{{ classDataName (getReferenceClassType table) 'Stored' }}>();
  const [firstItem, setFirstItem] = useState<{{ classDataName (getReferenceClassType table) 'Stored' }}>();
  const [isNextButtonEnabled, setIsNextButtonEnabled] = useState<boolean>(true);
  {{/ unless }}

  const isLoading = useMemo(() => isInternalLoading || !!isOwnerLoading, [isInternalLoading, isOwnerLoading]);

  {{# unless container.isSelector }}
  const selectedRows = useRef<{{ classDataName (getReferenceClassType table) 'Stored' }}[]>([]);
  {{/ unless }}
  {{# if (stringValueIsTrue useTableContextMenus) }}
  const contextMenuRef = useRef<ContextMenuApi>(null);

  const handleContextMenu = (event: MouseEvent<HTMLElement>) => {
    contextMenuRef.current?.handleContextMenu(event);
  };
  {{/ if }}

  {{# each table.columns as |column| }}
  const {{ column.name }}Column: GridColDef<{{ classDataName (getReferenceClassType table) 'Stored' }}> = {
    ...baseColumnConfig,
    field: '{{ column.attributeType.name }}',
    headerName: t('{{ getTranslationKeyForVisualElement column }}', { defaultValue: '{{ column.label }}' }) as string,
    headerClassName: 'data-grid-column-header',
    {{# if isDebugPrint }}// include: actor/src/fragments/relation/column.fragment.hbs{{/ if }}
    {{> actor/src/fragments/relation/column.fragment.hbs column=column ref=table name=table.name }}
  };
  {{/ each }}

  const columns = useMemo<GridColDef<{{ classDataName (getReferenceClassType table) 'Stored' }}>[]>(() => [
    {{# each table.columns as |column| }}
      {{# if column.customImplementation }}
        {{ column.name }}ColumnCustomizer ? {{ column.name }}ColumnCustomizer({{ column.name }}Column) : {{ column.name }}Column,
      {{ else }}
        {{ column.name }}Column,
      {{/ if }}
    {{/ each }}
  ], [{{# or (tableHasNumericColumn table) (tableHasDateColumn table) (tableHasDateTimeColumn table) }}l10nLocale{{/ or }}]);

  const rowActions: TableRowAction<{{ classDataName (getReferenceClassType table) 'Stored' }}>[] = useMemo(() =>[
    {{# each table.rowActionButtonGroup.buttons as |button| }}
    {{# unless button.actionDefinition.isOpenPageAction }}
    {
      id: '{{ getXMIID button }}',
      label: t('{{ getTranslationKeyForVisualElement button }}', { defaultValue: '{{ button.label }}' }) as string,
      {{# if button.icon }}
      icon: <MdiIcon path="{{ button.icon.iconName }}" />,
      {{/ if }}
      disabled: (row: {{ classDataName (getReferenceClassType table) 'Stored' }}) => {{{ tableRowButtonDisabledConditions button table container }}},
      action: actions.{{ simpleActionDefinitionName button.actionDefinition }} ? async (rowData) => {
        {{# if button.confirmation }}
          const result = await openConfirmDialog(
            '{{ getXMIID button }}',
            t('{{ getTranslationKeyForVisualElement button }}.confirmation', { defaultValue: '{{ button.confirmation.confirmationMessage }}' }) as string,
            t('judo.modal.confirm.confirm-title', { defaultValue: 'Confirm action' }) as string,
          );

          if (!result) {
            return;
          }
        {{/ if }}
        await actions.{{ simpleActionDefinitionName button.actionDefinition }}!(rowData);
      } : undefined,
    },
    {{/ unless }}
    {{/ each }}
  ], [actions, isLoading]);

  const effectiveTableColumns = useMemo(() => [ ...columns, ...columnsActionCalculator('{{ createId table.dataElement }}', rowActions, t, { shownActions: 2 }) ], [columns, rowActions]);

  const getRowIdentifier: (row: Pick<{{ classDataName (getReferenceClassType table) 'Stored' }}, '__identifier'>) => string = (row) => row.__identifier!;

  const getSelectedRows: () => {{ classDataName (getReferenceClassType table) 'Stored' }}[] = () => {
    return {{# if (tableHasSelectorColumn table) }}{{# if container.isSelector }}selectionDiff{{ else }}selectedRows.current{{/ if }}{{ else }}[]{{/ if }};
  };

  const clearSelections = () => {
    handleOnSelection([]);
  };

  const additionalToolbarActions: Record<string, ElementType> = actions?.{{ table.relationType.name }}AdditionalToolbarButtons ? actions.{{ table.relationType.name }}AdditionalToolbarButtons(
    data,
    isLoading,
    getSelectedRows(),
    clearSelections
    {{# unless container.table }}
    , ownerData
    , editMode
    , isFormUpdateable
    {{/ unless }}
  ) : {};
  const AdditionalToolbarActions = () => {
    return <>
      { Object.keys(additionalToolbarActions).map((key) => {
        const AdditionalButton = additionalToolbarActions[key];
        return <AdditionalButton key={key} />;
      }) }
    </>;
  };

  const pageSizeOptions = useMemo(() => {
    const opts: Set<number> = new Set([rowsPerPage, ...basePageSizeOptions]);
    return Array.from(opts.values()).sort((a, b) => a - b);
  }, [rowsPerPage]);

  const setPageSize = useCallback((newValue: number) => {
    setRowsPerPage(newValue);
    {{# unless table.isEager }}
      setPage(0);
    {{ else }}
      setPaginationModel((prevState) => ({
        ...prevState,
        pageSize: newValue,
        page: 0,
      }));
    {{/ unless }}

    setQueryCustomizer((prevQueryCustomizer: {{ classDataName (getReferenceClassType table) 'QueryCustomizer' }}) => {
      // we need to reset _seek so that previous configuration is erased
      return {
        ...prevQueryCustomizer,
        _seek: {
          limit: newValue + 1,
        },
      };
    });
  }, []);

  const filterOptions = useMemo<FilterOption[]>(() => [
    {{# each table.filters as |filter| }}
    {{# if isDebugPrint }}// include: actor/src/fragments/table/filter-option.fragment.hbs{{/ if }}
    {{> actor/src/fragments/table/filter-option.fragment.hbs filter=filter application=application }}
    {{/ each }}
  ], [{{# or (tableHasNumericColumn table) (tableHasDateColumn table) (tableHasDateTimeColumn table) }}l10nLocale{{/ or }}]);

  {{# if isUseInlineColumnFilters }}
  function handleFilterModelChange (newModel: GridFilterModel) {
    setFilterModel(newModel);
    setItemStringified(filterModelKey, newModel);

    if (newModel.items.every(i => i.value !== undefined)) {
      const newFilters: Filter[] = mapFilterModelToFilters(newModel, filterOptions);

      if (Array.isArray(newFilters)) {
        handleFiltersChange(newFilters);
      }
    }
  }
  {{/ if }}

  const handleFiltersChange = (newFilters: Filter[]) => {
    {{# unless table.isEager }}
    setPage(0);
    {{ else }}
    setPaginationModel((prevState) => ({
      ...prevState,
      page: 0,
    }));
    {{/ unless }}
    setFilters(newFilters);
    setItemStringified(filtersKey, newFilters);

    setQueryCustomizer((prevQueryCustomizer: {{ classDataName (getReferenceClassType table) 'QueryCustomizer' }}) => {
      // remove previous filter values, so that we can always start with a clean slate
      for (const name of columns.map(c => c.field)) {
        delete (prevQueryCustomizer as any)[name];
      }
      return {
        ...prevQueryCustomizer,
        _seek: {
          limit: rowsPerPage + 1,
        },
        ...mapAllFiltersToQueryCustomizerProperties(newFilters),
      };
    });
  };

  function handleSortModelChange (newModel: GridSortModel) {
    {{# unless table.isEager }}
    setPage(0);
    {{ else }}
    setPaginationModel((prevState) => ({
      ...prevState,
      page: 0,
    }));
    {{/ unless }}
    setSortModel(newModel);

    const _orderBy = newModel.filter(m => m.sort).map(m => ({
      attribute: m.field,
      descending: m.sort === 'desc',
    }));

    setQueryCustomizer((prevQueryCustomizer) => {
      const strippedQueryCustomizer: {{ classDataName (getReferenceClassType table) 'QueryCustomizer' }} = {
        ...prevQueryCustomizer
      };
      if (!!strippedQueryCustomizer._seek) {
        delete strippedQueryCustomizer._seek.lastItem;
      }
      // we need to reset _seek so that previous configuration is erased
      return {
        ...strippedQueryCustomizer,
        _orderBy,
        _seek: {
          limit: rowsPerPage + 1,
        },
      };
    });
  }

  {{# unless table.isEager }}
  async function handlePageChange (isNext: boolean) {
    setQueryCustomizer((prevQueryCustomizer) => {
      return {
        ...prevQueryCustomizer,
        _seek: {
          limit: isNext ? rowsPerPage + 1 : rowsPerPage,
          reverse: !isNext,
          lastItem: isNext ? lastItem : firstItem,
        },
      };
    });

    setIsNextButtonEnabled(!isNext);
  }
  {{/ unless }}

  {{# if container.isSelector }}
  const handleIsRowSelectable = useCallback((params: GridRowParams<{{ classDataName (getReferenceClassType table) 'Stored' }} & { __selected?: boolean }>) => {
    {{# unless container.isRelationSelector }}
    // For operation inputs, we allow all elements to be selected.
    return true;
    {{ else }}
    return isRowSelectable(params.row, !{{ boolValue table.allowSelectMultiple }}{{# if container.isRelationSelector }}, alreadySelected{{/ if }});
    {{/ unless }}
  }, []);

  const handleOnSelection = (newSelectionModel: GridRowSelectionModel) => {
    if (!Array.isArray(selectionModel)) return;
    {{# if table.allowSelectMultiple }}
    // added new items
    if (newSelectionModel.length > selectionModel.length) {
      const diff = newSelectionModel.length - selectionModel.length;
      const newItemsId = [...newSelectionModel].slice(diff * -1);
      const newItems = data.filter((value) => newItemsId.indexOf(value.__identifier as GridRowId) !== -1);
      setSelectionDiff((prevSelectedItems: {{ classDataName (getReferenceClassType table) 'Stored' }}[]) => {
        if (!Array.isArray(prevSelectedItems)) return [];

        return [...prevSelectedItems, ...newItems];
      });
    }

    // removed items
    if (newSelectionModel.length < selectionModel.length) {
      const removedItemsId = selectionModel.filter((value) => newSelectionModel.indexOf(value) === -1);
      setSelectionDiff((prevSelectedItems: {{ classDataName (getReferenceClassType table) 'Stored' }}[]) => {
        if (!Array.isArray(prevSelectedItems)) return [];

        return [...prevSelectedItems.filter((value) => removedItemsId.indexOf(value.__identifier as GridRowId) === -1)];
      });
    }

    setSelectionModel(newSelectionModel);
    {{ else }}
    if (newSelectionModel.length === 0) {
      setSelectionModel([]);
      setSelectionDiff([]);
      return;
    }

    const lastId = newSelectionModel[newSelectionModel.length - 1];

    setSelectionModel([lastId]);
    setSelectionDiff([data.find((value) => value.__identifier === lastId)!]);
    {{/ if }}
  };
  {{ else }}
  const handleOnSelection = (newSelectionModel: GridRowSelectionModel) => {
    selectedRows.current = getUpdatedRowsSelected(selectedRows, data, newSelectionModel);
    setSelectionModel(selectedRows.current.map(getRowIdentifier));
  }
  {{/ if }}

  {{# unless table.isEager }}
  async function fetchData() {
    if (!isLoading{{# unless container.table }} && ownerData.__signedIdentifier{{/ unless }}) {
      setIsInternalLoading(true);

      try {
        const processedQueryCustomizer = {
          ...processQueryCustomizer(queryCustomizer),
          {{# if (getRefreshActionDefinitionForTable table) }}
          _mask: actions.get{{ firstToUpper table.relationName }}Mask ? actions.get{{ firstToUpper table.relationName }}Mask() : queryCustomizer._mask,
          {{/ if }}
        };
        {{# if container.isSelector }}
        {{# with (getRangeActionDefinitionForTable table) as |actionDefinition| }}
        const res = await actions.{{ simpleActionDefinitionName actionDefinition }}!(processedQueryCustomizer);
        {{/ with }}
        {{ else }}
        {{# with (getRefreshActionDefinitionForTable table) as |actionDefinition| }}
        const res = await actions.{{ simpleActionDefinitionName actionDefinition }}!(processedQueryCustomizer);
        {{/ with }}
        {{/ if }}

        if (res.length > rowsPerPage) {
          setIsNextButtonEnabled(true);
          res.pop();
        } else if (queryCustomizer._seek?.limit === rowsPerPage + 1) {
          setIsNextButtonEnabled(false);
        }

        setData(res);
        setFirstItem(res[0]);
        setLastItem(res[res.length - 1]);
        setRowCount(res.length || 0);
      } catch (error) {
        handleError(error);
      } finally {
        setIsInternalLoading(false);
      }
    }
  }

  useEffect(() => {
    fetchData();
    handleOnSelection(selectionModel);
  }, [queryCustomizer{{# unless table.isEager }}, refreshCounter{{/ unless }}]);
  {{ else }}
  useEffect(() => {
    {{# with (getReferenceClassType table) as |classType| }}
    const newData = applyInMemoryFilters<{{# if classType.isMapped}}{{ classDataName classType 'Stored' }}{{ else }}{{ classDataName classType '' }}{{/ if }}>(filters, {{# unless table.isSelectorTable }}ownerData?.{{ table.dataElement.name }} ?? []{{ else }}data{{/ unless}});
    {{/ with }}
    setData(newData);
    handleOnSelection(selectionModel);
  }, [{{# unless table.isSelectorTable }}ownerData?.{{ table.dataElement.name }}, {{/ unless }}filters]);

  {{# if isUseInlineColumnFilters}}
  useEffect(() => {
    if (filterModel.items.every((i) => i.value !== undefined)) {
      setFilters(mapFilterModelToFilters(filterModel, filterOptions));
    }
  }, [{{# unless table.isSelectorTable }}ownerData?.{{ table.dataElement.name }}, {{/ unless }}filterModel]);
  {{/ if }}
  {{/ unless }}

  return (
    <div id="{{ getXMIID table }}" data-table-name="{{ table.name }}">
      <StripedDataGrid
        { ...baseTableConfig }
        {{# if isMUILicensePlanPro }}
        initialState={ { pinnedColumns: { right: ['actions'] } } }
        {{/ if }}
        pageSizeOptions={pageSizeOptions}
        sx={ {
          // overflow: 'hidden',
          display: 'grid',
          {{# unless container.table }}
          border: (theme) => validationError ? `2px solid ${theme.palette.error.main}` : undefined,
          {{/ unless }}
          {{# if (stringValueIsTrue useTableRowHighlighting) }}
          ...transformRowStylings(rowStylings),
          {{/ if }}
        } }
        slotProps={ {
        {{# if (stringValueIsTrue useTableContextMenus) }}
          cell: {
            onContextMenu: handleContextMenu,
          },
        {{/ if }}
          filterPanel: {
            logicOperators: [GridLogicOperator.And],
          },
        } }
        getRowId={getRowIdentifier}
        loading={isLoading}
        rows={data}
        getRowClassName={ (params: GridRowClassNameParams) => {
          {{# if (stringValueIsTrue useTableRowHighlighting) }}
          const customStyle = rowStylings.find(r => r.condition(params));
          if (customStyle) {
            return customStyle.name;
          }
          {{/ if }}
          return params.indexRelativeToCurrentPage % 2 === 0 ? 'even' : 'odd';
        } }
        columns={effectiveTableColumns}
        disableRowSelectionOnClick
        {{# if table.isSelectorTable }}
        isRowSelectable={handleIsRowSelectable}
        hideFooterSelectedRowCount={ !{{ boolValue table.allowSelectMultiple }} }
        {{/ if }}
        {{# if (tableHasSelectorColumn table) }}
        checkboxSelection
        rowSelectionModel={selectionModel}
        onRowSelectionModelChange={handleOnSelection}
        {{/ if }}
        keepNonExistentRowsSelected
        {{# each table.rowActionDefinitions as |actionDefinition| }}
        {{# if actionDefinition.isOpenPageAction }}
        onRowClick={ actions.{{ simpleActionDefinitionName actionDefinition }} ? async (params: GridRowParams<{{ classDataName (getReferenceClassType table) 'Stored' }}>) => await actions.{{ simpleActionDefinitionName actionDefinition }}!(params.row) : undefined }
        {{/ if }}
        {{/ each }}
        sortModel={sortModel}
        onSortModelChange={handleSortModelChange}
        {{# if isUseInlineColumnFilters }}
        filterModel={filterModel}
        onFilterModelChange={handleFilterModelChange}
        {{/ if }}
        paginationModel={paginationModel}
        onPaginationModelChange={setPaginationModel}
        {{# unless table.isEager }}
        paginationMode="server"
        sortingMode="server"
        filterMode="server"
        rowCount={rowsPerPage}
        {{/ unless }}
        components={ {
          Toolbar: () => (
            <GridToolbarContainer>
              {{# each table.tableActionButtonGroup.buttons as |button| }}
              {actions.{{ simpleActionDefinitionName button.actionDefinition }} && ({{{ tableButtonVisibilityConditions button table container }}}) ? <Button
                id="{{ getXMIID button }}"
                {{# if button.icon }}
                startIcon={<MdiIcon path="{{ button.icon.iconName }}" />}
                {{/ if }}
                variant={ {{{ variantForButton button }}} }
                onClick={ async () => {
                  {{# if button.actionDefinition.isFilterAction }}
                  const filterResults = await actions.{{ simpleActionDefinitionName actionDefinition }}!('{{ createId button }}', filterOptions, filterModel, filters);
                  {{# if isUseInlineColumnFilters }}
                  if (filterResults.model) {
                    handleFilterModelChange({
                      ...filterResults.model!,
                    });
                  }
                  {{ else }}
                  if (Array.isArray(filterResults.filters)) {
                    handleFiltersChange([...filterResults.filters!]);
                  }
                  {{/ if }}
                  {{ else }}
                  const processedQueryCustomizer = {
                    ...processQueryCustomizer(queryCustomizer),
                    {{# if (getRefreshActionDefinitionForTable table) }}
                    _mask: actions.get{{ firstToUpper table.relationName }}Mask ? actions.get{{ firstToUpper table.relationName }}Mask() : queryCustomizer._mask,
                    {{/ if }}
                  };
                  {{# if actionDefinition.isRefreshAction }}
                  await actions.{{ simpleActionDefinitionName actionDefinition }}!(processedQueryCustomizer);
                  {{ else }}
                  {{# if actionDefinition.isSelectorRangeAction }}
                  await actions.{{ simpleActionDefinitionName actionDefinition }}!(processedQueryCustomizer);
                  {{ else }}
                  {{# if actionDefinition.isBulk }}
                  const { result: bulkResult } = await actions.{{ simpleActionDefinitionName actionDefinition }}!(selectedRows.current);
                  if (bulkResult === 'submit') {
                    handleOnSelection([]); // not resetting on refreshes because refreshes would always remove selections...
                  }
                  {{ else }}
                  {{# if actionDefinition.isClearAction }}
                  await actions.{{ simpleActionDefinitionName actionDefinition }}!();
                  handleOnSelection([]);
                  {{ else }}
                  await actions.{{ simpleActionDefinitionName actionDefinition }}!();
                  {{/ if }}
                  {{/ if }}
                  {{/ if }}
                  {{/ if }}
                  {{/ if }}
                } }
                disabled={ {{{ tableToolbarButtonDisabledConditions button table container }}} }
              >
                {t('{{ getTranslationKeyForVisualElement button }}', { defaultValue: '{{ button.label }}' })}
                {{# if button.actionDefinition.isFilterAction }}
                {filters.length ? ` (${filters.length})` : ''}
                {{/ if }}
              </Button> : null}
              {{/ each }}
              {<AdditionalToolbarActions />}
              <div>{/* Placeholder */}</div>
            </GridToolbarContainer>
          ),
          {{# unless table.isEager }}
          Pagination: () => (
            <CustomTablePagination
              pageSizeOptions={pageSizeOptions}
              setPageSize={setPageSize}
              pageChange={handlePageChange}
              isNextButtonEnabled={isNextButtonEnabled}
              page={page}
              setPage={setPage}
              rowPerPage={rowsPerPage}
            />
          ),
          {{/ unless }}
        } }
      />
      {{> actor/src/fragments/table/error-feedback.fragment.hbs }}
      {{# if (stringValueIsTrue useTableRowHighlighting) }}
      <RowHighlightLegend rowStylings={rowStylings} />
      {{/ if }}
      {{# if (stringValueIsTrue useTableContextMenus) }}
      <ContextMenu
        ref={contextMenuRef}
        data={data}
        filters={filters}
        filterOptions={filterOptions}
        columns={columns}
        onFilterByCell={ (filter: Filter) => {
          {{# if isUseInlineColumnFilters }}
          handleFilterModelChange({
            ...filterModel,
            items: [...filterModel.items, mapFilterToFilterModel(filter)],
          });
          {{ else }}
          handleFiltersChange([...filters, filter]);
          {{/ if }}
        } }
        onExcludeByCell={ (filter: Filter) => {
          {{# if isUseInlineColumnFilters }}
          handleFilterModelChange({
            ...filterModel,
            items: [...filterModel.items, mapFilterToFilterModel(filter)],
          });
          {{ else }}
          handleFiltersChange([...filters, filter]);
          {{/ if }}
        } }
      />
      {{/ if }}
    </div>
  );
}
