{{> fragment.header.hbs }}

import { useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { exists, processQueryCustomizer } from '~/utilities';
import { MdiIcon } from '~/components';
import { AggregationInput } from '~/components/widgets';
import { StringOperation } from '~/services/data-api/model/StringOperation';
import type {
  {{ getLinkAPIImports link container }}
} from '~/services/data-api';
import { AggregationInputButtonProps } from '~/utilities/application/interfaces';
import type { {{ componentName link }}ActionDefinitions, {{ componentName link }}Props } from './types';

// XMIID: {{ getXMIID link }}
// Name: {{ link.name }}
export function {{ componentName link }}(props: {{ componentName link }}Props) {
  const { ownerData, actions, storeDiff, submit, validationError, disabled, readOnly, editMode, isLoading, isDraft } = props;
  const { t } = useTranslation();


  const aggregationInputButtonProps: AggregationInputButtonProps[] = useMemo( () => [
    {{# each link.actionButtonGroup.buttons as |button| }}
    {
      name: "{{ firstToLower button.label }}",
      className: "{{ link.dataElement.name }}-{{ firstToLower button.label }}",
    {{# if button.actionDefinition.isOpenSelectorAction }}
      visible: (value: any, onClick?: () => void) => !exists(value) && onClick !== undefined && !readOnly,
      dropDownButtonIsVisible: (value: any, onClick?: () => void) => exists(value) && onClick !== undefined && !readOnly,
      disabled: disabled,
      onClick: actions.{{ simpleActionDefinitionName actionDefinition }} ? async () => {
        const {{ link.dataElement.name }} = await actions.{{ simpleActionDefinitionName actionDefinition }}!();
        {{# if link.onBlur }}
        if ({{ link.dataElement.name }} && actions?.on{{ firstToUpper link.dataElement.name }}BlurAction) {
          const eagerCopy = { ...ownerData, ['{{ link.dataElement.name }}']: {{ link.dataElement.name }} };
          actions.on{{ firstToUpper link.dataElement.name }}BlurAction(eagerCopy as {{ classDataName container.dataElement 'Stored' }}, storeDiff, editMode!, submit);
        }
        {{/ if }}
      } : undefined,
      title: t('judo.component.AggregationInput.open-filter', { defaultValue: 'Open selector dialog' }) as string,
    {{/ if }}
    {{# if button.actionDefinition.isUnsetAction }}
      dropDownButtonIsVisible: (value: any, onClick?: () => void) => exists(value) && onClick !== undefined && !readOnly,
      disabled: disabled,
      onClick: (ownerData.{{ link.dataElement.name }} && actions.{{ simpleActionDefinitionName actionDefinition }}) ? async () => {
        actions.{{ simpleActionDefinitionName actionDefinition }}!(ownerData.{{ link.dataElement.name }}!)
      } : undefined,
      title: t('judo.component.AggregationInput.unset', { defaultValue: 'Unset' }) as string,
    {{/ if }}
    {{# if button.actionDefinition.isOpenPageAction }}
      visible: (value: any, onClick?: () => void) => exists(value) && onClick !== undefined,
      disabled: editMode && !({{ boolValue link.dataElement.isInlineCreatable }} && !isDraft),
      onClick: (ownerData.{{ link.dataElement.name }} && actions.{{ simpleActionDefinitionName actionDefinition }}) ? async () => {
        await actions.{{ simpleActionDefinitionName actionDefinition }}!(ownerData.{{ link.dataElement.name }}!, {{# if container.form }}true{{ else }}false{{/ if }});
      } : undefined,
      title: t('judo.component.AggregationInput.navigate', { defaultValue: 'Navigate to element' }) as string,
    {{/ if }}
    {{# if button.actionDefinition.isOpenFormAction }}
      visible: (value: any, onClick?: () => void) => !exists(value) && onClick !== undefined && !readOnly,
      disabled: disabled || (editMode && !({{ boolValue link.dataElement.isInlineCreatable }} && !isDraft)),
      onClick: actions.{{ simpleActionDefinitionName actionDefinition }} ? async () => {
        await actions.{{ simpleActionDefinitionName actionDefinition }}!();
      } : undefined,
      title: t('judo.component.AggregationInput.create', { defaultValue: 'Create' }) as string,
    {{/ if }}
    {{# if button.actionDefinition.isDeleteAction }}
      dropDownButtonIsVisible: (value: any, onClick?: () => void) => exists(value) && onClick !== undefined,
      disabled: disabled || editMode,
      onClick: (ownerData.{{ link.dataElement.name }} && ownerData.{{ link.dataElement.name }}.__deleteable && actions.{{ simpleActionDefinitionName actionDefinition }}) ? async () => {
        actions.{{ simpleActionDefinitionName actionDefinition }}!(ownerData.{{ link.dataElement.name }}!)
      }
      : undefined,
      title: t('judo.component.AggregationInput.delete', { defaultValue: 'Delete' }) as string,
    {{/ if }}
      iconName: '{{ button.icon.iconName }}',
    },
  {{/ each }}
  ], [readOnly, editMode, isDraft, disabled, ownerData, actions]);

  return (
    <AggregationInput
      name="{{ link.dataElement.name }}"
      id="{{ getXMIID link }}"
      label={ t('{{ getTranslationKeyForVisualElement link }}', { defaultValue: '{{ link.label }}' }) as string }
      required={actions?.is{{ firstToUpper link.relationType.name }}Required ? actions.is{{ firstToUpper link.relationType.name }}Required(ownerData, editMode) : ({{# if link.requiredBy }}ownerData.{{ link.requiredBy.name }} || {{/ if }}{{# unless link.dataElement.isOptional }}true{{ else }}false{{/ unless }})}
      ownerData={ownerData}
      error={!!validationError}
      helperText={validationError}
      {{# if link.icon }}
        icon={<MdiIcon path="{{ link.icon.iconName }}" />}
      {{/ if }}
      disabled={actions?.is{{ firstToUpper link.relationType.name }}Disabled ? actions.is{{ firstToUpper link.relationType.name }}Disabled(ownerData, editMode, isLoading) : disabled}
      readOnly={readOnly}
      editMode={editMode}
      isInlineCreatable={ {{ boolValue link.dataElement.isInlineCreatable }} && !isDraft }
      autoCompleteAttribute={'{{ link.parts.[0].attributeType.name }}'}
      aggregationInputButtonProps={aggregationInputButtonProps}
      onAutoCompleteSelect={ ({{ link.dataElement.name }}) => {
        storeDiff('{{ link.dataElement.name }}', {{ link.dataElement.name }});
        {{# if link.onBlur }}
        if (actions?.on{{ firstToUpper link.dataElement.name }}BlurAction) {
          const eagerCopy = { ...ownerData, ['{{ link.dataElement.name }}']: {{ link.dataElement.name }} };
          actions.on{{ firstToUpper link.dataElement.name }}BlurAction(eagerCopy as {{ classDataName container.dataElement 'Stored' }}, storeDiff, editMode!, submit);
        }
        {{/ if }}
      } }
{{# if (isAutocompleteAvailable link) }}
  {{# with (getFirstAutocompleteColumnForLink link) as |column| }}
    {{# with link.autocompleteRangeActionDefinition as |actionDefinition| }}
      onAutoCompleteSearch={ actions.{{ simpleActionDefinitionName actionDefinition }} ? async (searchText: string) => {
        const queryCustomizer: {{ classDataName link.dataElement.target 'QueryCustomizer' }} = {
          ...(searchText?.length ? {
            {{ column.attributeType.name }}: [
              { operator: StringOperation.like, value: searchText }
            ],
          } : {}),
          _mask: '{{ getMaskForLink link }}',
          _orderBy: [
            {{# with (getSortColumnForLink link) as |sortColumn| }}
            { attribute: '{{ sortColumn.attributeType.name }}', descending: {{ isSortDirectionDescending sortColumn }} },
            {{/ with }}
          ],
          _seek: { limit: {{ calculateLinkAutocompleteRows link }} },
        };
        return await actions.{{ simpleActionDefinitionName actionDefinition }}!(processQueryCustomizer(queryCustomizer));
      } : undefined }
    {{/ with }}
  {{/ with }}
{{/ if }}
    />
  );
}
