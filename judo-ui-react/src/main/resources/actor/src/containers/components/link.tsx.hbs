{{> fragment.header.hbs }}

import { useTranslation } from 'react-i18next';
import { IconButton } from '@mui/material';
import { processQueryCustomizer } from '~/utilities';
import { MdiIcon } from '~/components';
import {
  AggregationInput,
  AssociationButton,
  BinaryInput,
  CollectionAssociationButton,
  TrinaryLogicCombobox,
} from '~/components/widgets';
import { StringOperation } from '~/generated/data-api';
import type {
  {{ classDataName container.dataElement '' }},
  {{ classDataName container.dataElement 'Stored' }},
  {{ classDataName link.dataElement.target 'Stored' }},
  {{ classDataName link.dataElement.target 'QueryCustomizer' }},
} from '~/generated/data-api';

export interface {{ linkComponentName link }}ActionDefinitions {
  {{# each link.actionDefinitions as |actionDefinition| }}
    {{# if actionDefinition.isAutocompleteRangeAction }}
      {{ simpleActionDefinitionName actionDefinition }}?: (queryCustomizer: {{ classDataName link.dataElement.target 'QueryCustomizer' }}) => Promise<{{ classDataName link.dataElement.target 'Stored' }}[]>;
    {{ else }}
      {{ simpleActionDefinitionName actionDefinition }}?: ({{# if actionDefinition.targetType }}target: {{ classDataName actionDefinition.targetType 'Stored' }}{{/ if }}) => Promise<void>;
    {{/ if }}
  {{/ each }}
}

export interface {{ linkComponentName link }}Props {
  ownerData: {{ classDataName container.dataElement '' }} | {{ classDataName container.dataElement 'Stored' }};
  actions: {{ linkComponentName link }}ActionDefinitions;
  storeDiff: (attributeName: keyof {{ classDataName container.dataElement '' }}, value: any) => void;
  validationError?: string;
  disabled?: boolean;
  editMode?: boolean;
}

// Name: {{ link.name }}
export function {{ linkComponentName link }}(props: {{ linkComponentName link }}Props) {
  const { ownerData, actions, storeDiff, validationError, disabled, editMode } = props;
  const { t } = useTranslation();

  return (
    <AggregationInput
      name="{{ link.dataElement.name }}"
      id="{{ createId link }}"
      label={ t('{{ getTranslationKeyForVisualElement link }}', { defaultValue: '{{ link.label }}' }) as string {{# if link.attributeType.isRequired }} + " *" {{/ if }} }
      labelList={[
        {{# each link.parts as |part| }}
          ownerData.{{ link.dataElement.name }}?.{{ part.attributeType.name }}?.toString() ?? '',
        {{/ each }}
      ]}
      ownerData={ownerData}
      error={!!validationError}
      helperText={validationError}
      {{# if link.icon }}
        icon={<MdiIcon path="{{ link.icon.name }}" />}
      {{/ if }}
      disabled={disabled}
      editMode={editMode}
      autoCompleteAttribute={'{{ link.parts.[0].attributeType.name }}'}
      onAutoCompleteSelect={ ({{ link.dataElement.name }}) => {
        storeDiff('{{ link.dataElement.name }}', {{ link.dataElement.name }});
      } }
      {{# if (isAutocompleteAvailable link) }}
        {{# with (getFirstAutocompleteColumnForLink link) as |column| }}
          {{# with link.autocompleteRangeActionDefinition as |actionDefinition| }}
            onAutoCompleteSearch={ actions.{{ simpleActionDefinitionName actionDefinition }} ? async (searchText: string) => {
              const queryCustomizer: {{ classDataName link.dataElement.target 'QueryCustomizer' }} = {
                ...(searchText?.length ? {
                  {{ column.attributeType.name }}: [
                    { operator: StringOperation.like, value: searchText }
                  ],
                } : {}),
                _mask: '{ {{~ column.attributeType.name ~}} }',
                _orderBy: [
                  { attribute: '{{ column.attributeType.name }}', descending: false },
                ],
                _seek: { limit: 10 },
              };
              return await actions.{{ simpleActionDefinitionName actionDefinition }}!(processQueryCustomizer(queryCustomizer));
            } : undefined }
          {{/ with }}
        {{/ with }}
      {{/ if }}
      {{# each link.actionButtonGroup.buttons as |button| }}
        {{# if button.actionDefinition.isOpenSelectorAction }}
          onSet={ actions.{{ simpleActionDefinitionName actionDefinition }} }
        {{/ if }}
        {{# if button.actionDefinition.isUnsetAction }}
          onUnset={ actions.{{ simpleActionDefinitionName actionDefinition }} }
        {{/ if }}
        {{# if button.actionDefinition.isOpenPageAction }}
          onView={ (ownerData.{{ link.dataElement.name }} && actions.{{ simpleActionDefinitionName actionDefinition }}) ? async () => actions.{{ simpleActionDefinitionName actionDefinition }}!(ownerData.{{ link.dataElement.name }}!) : undefined }
        {{/ if }}
        {{# if button.actionDefinition.isCreateAction }}
          onCreate={ actions.{{ simpleActionDefinitionName actionDefinition }} }
        {{/ if }}
        {{# if button.actionDefinition.isDeleteAction }}
          onDelete={ actions.{{ simpleActionDefinitionName actionDefinition }} }
        {{/ if }}
        {{# if button.actionDefinition.isRemoveAction }}
          onRemove={ actions.{{ simpleActionDefinitionName actionDefinition }} }
        {{/ if }}
      {{/ each }}
    >
    </AggregationInput>
  );
}
