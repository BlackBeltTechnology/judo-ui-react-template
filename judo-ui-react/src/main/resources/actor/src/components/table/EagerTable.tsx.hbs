{{> fragment.header.hbs }}


import { DataGrid, GridColDef, GridFilterModel, GridLogicOperator, GridRowClassNameParams, GridRowModel, GridRowSelectionModel, GridSortModel, GridValidRowModel, useGridApiRef } from '@mui/x-data-grid';
import { ComponentProxy, useTrackComponent, useTrackService } from '@pandino/react-hooks';
import { FC, MouseEvent, useCallback, useMemo, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { Filter, FilterOption } from '~/components-api';
import {
ContextMenu,
ContextMenuApi,
StripedDataGrid,
columnsActionCalculator,
} from '~/components/table';
import { RowHighlightLegend } from '~/components/table';
import { baseColumnConfig, basePageSizeOptions, baseTableConfig } from '~/config';
import { useDataStore } from '~/hooks';
import { transformRowStylings } from '~/theme/table-row-highlighting';
import type { RowStylerConfigured, TableRowHighlightingHook } from '~/theme/table-row-highlighting';
import { useConfirmDialog } from '../dialog';
import { SidekickComponentProps, TableRowAction, mapAllFiltersToQueryCustomizerProperties } from '~/utilities';
import { QueryCustomizer } from '~/services/data-api/common';

interface EEagerTableProps<T extends GridValidRowModel> {
  sidekickComponentFilterProp: string;
  uniqueId: string;
  downloadFile: any;
  extractFileNameFromToken: any;
  rowHighlightingHookInterfaceKey: string;
  dataProp: T[];
  defaultSortParamsForTable: any;
  tablePageLimit: number;
  columnsProp: GridColDef<T>[];
  rowActionsProp: TableRowAction<T>[];
  effectiveTableColumnsProp: any;
  getSelectedRows: () => T[];
  clearSelections: () => void;
  AdditionalToolbarActions: () => JSX.Element;
  filterOptionsProp: FilterOption[];
  handleIsRowSelectable: any;
  mask: string;
  l10nLocale: string;
  isOwnerLoading?: boolean;
  validationError?: string;
  actions: TableRowAction<T>[];
  GridToolbarContainer: () => JSX.Element;
  allowSelectMultiple: boolean;
  handleOnSelection: any;
  rowAction: any;
  dataElementId: string;
  crudOperationDisplayed: number;
  transferOperationsDisplayed: number;
}


export function EEagerTable<T extends GridValidRowModel, S extends QueryCustomizer<T>>(props: EEagerTableProps<T>, dataGridProps: typeof DataGrid) {
      const {
        sidekickComponentFilterProp,
        uniqueId,
        l10nLocale,
        downloadFile,
        extractFileNameFromToken,
        rowHighlightingHookInterfaceKey,
        dataProp,
        defaultSortParamsForTable,
        tablePageLimit,
        columnsProp,
        rowActionsProp,
        effectiveTableColumnsProp,
        getSelectedRows,
        clearSelections,
        AdditionalToolbarActions,
        filterOptionsProp,
        handleIsRowSelectable,
        mask,
        isOwnerLoading,
        validationError,
        actions,
        allowSelectMultiple,
        handleOnSelection,
        rowAction,
        GridToolbarContainer,
        dataElementId,
        crudOperationDisplayed,
        transferOperationsDisplayed,
      } = props;

      const apiRef = useGridApiRef();
      const sidekickComponentFilter = sidekickComponentFilterProp;
      const filterModelKey = `${uniqueId}-filterModel`;
      const filtersKey = `${uniqueId}-filters`;
      const rowsPerPageKey = `${uniqueId}-rowsPerPage`;
      {{# if isMUILicensePlanPro }}
        const columnStateKey = `${uniqueId}-columnState`;
      {{/ if }}

      const { openConfirmDialog } = useConfirmDialog();
      const { getItemParsed, getItemParsedWithDefault, setItemStringified } = useDataStore('sessionStorage');
      const { t } = useTranslation();

      {{# if (stringValueIsTrue useTableRowHighlighting) }}
        const { service: rowHighlightingHook } = useTrackService<TableRowHighlightingHook<T>>(rowHighlightingHookInterfaceKey);
        const rowHighlighting = rowHighlightingHook && rowHighlightingHook();
        const rowStylings: RowStylerConfigured<T>[] = useMemo(() => {
        return rowHighlighting ? rowHighlighting() : [];
        }, [rowHighlighting]);
      {{/ if }}

      // TODO: create a variable for this #each (customizableColumns table) as |column|

      const [isInternalLoading, setIsInternalLoading] = useState<boolean>(false);
      const [data, setData] = useState<GridRowModel<T>[]>(dataProp);
      const [selectionModel, setSelectionModel] = useState<GridRowSelectionModel>([]);
      const [sortModel, setSortModel] = useState<GridSortModel>(defaultSortParamsForTable);
      const [filterModel, setFilterModel] = useState<GridFilterModel>(getItemParsedWithDefault(filterModelKey, { items: [] }));
      const [filters, setFilters] = useState<Filter[]>(getItemParsedWithDefault(filtersKey, []));
      {{# if isMUILicensePlanPro }}
        const [columnState, setColumnState] = useState<PersistedColumnInfo[]>(getItemParsedWithDefault(columnStateKey, []));
      {{/ if }}
      const [rowsPerPage, setRowsPerPage] = useState<number>(getItemParsedWithDefault(rowsPerPageKey, tablePageLimit));
      const [paginationModel, setPaginationModel] = useState({
        pageSize: rowsPerPage,
        page: 0,
      });

      const [queryCustomizer, setQueryCustomizer] = useState<S | QueryCustomizer<T>>({
        _mask: 'mask',
        _seek: {
        limit: rowsPerPage + 1,
        },
        _orderBy: sortModel.length ? [
        {
        attribute: sortModel[0].field,
        descending: sortModel[0].sort === 'desc',
        },
        ] : [],
        ...mapAllFiltersToQueryCustomizerProperties(filters),
      });
      const SidekickComponent = useTrackComponent<FC<SidekickComponentProps<T>>>(sidekickComponentFilter);

      const isLoading = useMemo(() => isInternalLoading || !!isOwnerLoading, [isInternalLoading, isOwnerLoading]);

      const selectedRows = useRef<T[]>([]);
      {{# if (stringValueIsTrue useTableContextMenus) }}
        const contextMenuRef = useRef<ContextMenuApi>(null);

        const handleContextMenu = (event: MouseEvent<HTMLElement>) => {
        contextMenuRef.current?.handleContextMenu(event);
        };
      {{/ if }}

      const columns = useMemo<GridColDef<T>[]>(() => columnsProp, [l10nLocale]);

      const rowActions: TableRowAction<T>[] = useMemo(() => rowActionsProp, [actions, isLoading]);

      const effectiveTableColumns = useMemo(() => {
        const cols = [
          ...columns,
          ...columnsActionCalculator(dataElementId, rowActions, t, { crudOperationsDisplayed: crudOperationDisplayed, transferOperationsDisplayed: transferOperationsDisplayed })
        ];
        {{# if isMUILicensePlanPro }}
          if (columnState.length) {
          const adjusted = columnState
          .sort((a, b) => a.index - b.index)
          .map((c) => cols.find((t) => t.field === c.field)!);
          for (const c of adjusted) {
          const colWithWidth = columnState.find(x => x.field === c.field && x.width !== undefined)
          if (colWithWidth) {
          // mutate in place
          c.width = colWithWidth.width;
          }
          }
          return adjusted;
          }
        {{/ if }}
        return cols;
      }, [columns, rowActions{{# if isMUILicensePlanPro }}, columnState{{/ if }}]);

      {{# if isMUILicensePlanPro }}
        const onColumnsChanged = () => {
        // Handles column resizing and re-ordering
        // skip selector column
        const newOrder: PersistedColumnInfo[] = gridColumnDefinitionsSelector(apiRef)
        .filter((c) => c.field !== '__check__')
        .map((current, idx) => ({ field: current.field, index: idx, width: current.computedWidth }));
        setItemStringified(columnStateKey, newOrder);
        setColumnState(newOrder);
        };
      {{/ if }}

      const getRowIdentifier: (row: Pick<T, '__identifier'>) => string = (row) => row.__identifier!;

      const pageSizeOptions = useMemo(() => {
        const opts: Set<number> = new Set([rowsPerPage, ...basePageSizeOptions]);
          return Array.from(opts.values()).sort((a, b) => a - b);
        }, [rowsPerPage]);

        // really need this in case of eager table
        const setPageSize = useCallback((newValue: number) => {
        setRowsPerPage(newValue);
        setItemStringified(rowsPerPageKey, newValue);
        setPaginationModel((prevState) => ({
          ...prevState,
          pageSize: newValue,
          page: 0,
        }));

        setQueryCustomizer((prevQueryCustomizer: S | QueryCustomizer<T>) => {
         // we need to reset _seek so that previous configuration is erased
         return {
           ...prevQueryCustomizer,
           _seek: {
             limit: newValue + 1,
           },
         };
        });
      }, []);

      const filterOptions = useMemo<FilterOption[]>(() => filterOptionsProp, [l10nLocale]);

      {{# if isUseInlineColumnFilters }}
        function handleFilterModelChange (newModel: GridFilterModel) {
          setFilterModel(newModel);
          setItemStringified(filterModelKey, newModel);

        if (newModel.items.every(i => i.value !== undefined)) {
          const newFilters: Filter[] = mapFilterModelToFilters(newModel, filterOptions);

          if (Array.isArray(newFilters)) {
            handleFiltersChange(newFilters);
          }
        }
      }
      {{/ if }}

      const handleFiltersChange = (newFilters: Filter[]) => {
        setPaginationModel((prevState) => ({
          ...prevState,
          page: 0,
        }));
        setFilters(newFilters);
        setItemStringified(filtersKey, newFilters);

        setQueryCustomizer((prevQueryCustomizer: S | QueryCustomizer<T>) => {
          // remove previous filter values, so that we can always start with a clean slate
          for (const name of columns.map(c => c.field)) {
            delete (prevQueryCustomizer as any)[name];
          }
          return {
            ...prevQueryCustomizer,
            _seek: {
              limit: rowsPerPage + 1,
            },
            ...mapAllFiltersToQueryCustomizerProperties(newFilters),
          };
        });
      };

      function handleSortModelChange (newModel: GridSortModel) {
        setPaginationModel((prevState) => ({
          ...prevState,
          page: 0,
        }));
        setSortModel(newModel);

        const _orderBy = newModel.filter(m => m.sort).map(m => ({
          attribute: m.field,
          descending: m.sort === 'desc',
        }));

        setQueryCustomizer((prevQueryCustomizer) => {
          const strippedQueryCustomizer: S = {
            ...prevQueryCustomizer
          };
          if (!!strippedQueryCustomizer._seek) {
            delete strippedQueryCustomizer._seek.lastItem;
          }
          // we need to reset _seek so that previous configuration is erased
          return {
            ...strippedQueryCustomizer,
            _orderBy,
            _seek: {
              limit: rowsPerPage + 1,
            },
          };
        });
      }

  return (
    <StripedDataGrid
    apiRef={apiRef}
    { ...baseTableConfig }
    {{# if isMUILicensePlanPro }}
    initialState={ { pinnedColumns: { right: ['actions'] } } }
    {{/ if }}
    pageSizeOptions={pageSizeOptions}
    sx={ {
    // overflow: 'hidden',
    display: 'grid',
    border: (theme) => props.validationError ? `2px solid ${theme.palette.error.main}` : undefined,
    {{# if (stringValueIsTrue useTableRowHighlighting) }}
      ...transformRowStylings(rowStylings),
    {{/ if }}
    } }
    slotProps={ {
    {{# if (stringValueIsTrue useTableContextMenus) }}
      cell: {
      onContextMenu: handleContextMenu,
      },
    {{/ if }}
    filterPanel: {
    logicOperators: [GridLogicOperator.And],
    },
    } }
    getRowId={getRowIdentifier}
    loading={isLoading}
    rows={data}
    getRowClassName={ (params: GridRowClassNameParams) => {
    {{# if (stringValueIsTrue useTableRowHighlighting) }}
      const customStyle = rowStylings.find(r => r.condition(params));
      if (customStyle) {
      return customStyle.name;
      }
    {{/ if }}
    return params.indexRelativeToCurrentPage % 2 === 0 ? 'even' : 'odd';
    } }
    columns={effectiveTableColumns}
    {{# if isMUILicensePlanPro }}
      onColumnOrderChange={onColumnsChanged}
      onColumnWidthChange={onColumnsChanged}
    {{/ if }}
     disableRowSelectionOnClick
     isRowSelectable={handleIsRowSelectable}
     hideFooterSelectedRowCount={ !allowSelectMultiple }
     checkboxSelection
     rowSelectionModel={selectionModel}
     onRowSelectionModelChange={handleOnSelection}
    keepNonExistentRowsSelected
    onRowClick={rowAction}
    sortModel={sortModel}
    onSortModelChange={handleSortModelChange}
    {{# if isUseInlineColumnFilters }}
      filterModel={filterModel}
      onFilterModelChange={handleFilterModelChange}
    {{/ if }}
    paginationModel={paginationModel}
    onPaginationModelChange={setPaginationModel}
    components={ {
    Toolbar: () => (
      <GridToolbarContainer/>
    ),
    } }
    />
  );
}
