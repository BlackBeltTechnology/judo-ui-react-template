{{> fragment.header.hbs }}

import Autocomplete from '@mui/material/Autocomplete';
import ButtonGroup from '@mui/material/ButtonGroup';
import CircularProgress from '@mui/material/CircularProgress';
import IconButton from '@mui/material/IconButton';
import InputAdornment from '@mui/material/InputAdornment';
import TextField from '@mui/material/TextField';
import { debounce } from '@mui/material/utils';
import clsx from 'clsx';
import { type MouseEvent, type SyntheticEvent, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { MdiIcon } from '~/components/MdiIcon';
import { debounceInputs } from '~/config/general';
import { QueryCustomizer } from '~/services/data-api/common/QueryCustomizer';
import { StringOperation } from '~/services/data-api/model/StringOperation';

export interface TagsProps<P, T> {
  id: string;
  label: string;
  ownerData: P;
  name: keyof P;
  error?: boolean;
  readOnly?: boolean;
  disabled?: boolean;
  helperText?: string;
  editMode?: boolean;
  autoCompleteAttribute: keyof T;
  identifierAttribute: string | keyof T;
  onAutoCompleteSearch?: (searchText: string, preparedQueryCustomizer: QueryCustomizer<T>) => Promise<T[]>;
  additionalMaskAttributes?: string[];
  limitOptions?: number;
  onValueChange?: (target: T[]) => Promise<void>;
  onItemClick?: (target: T) => void;
  onSearchDialogsClick?: () => void;
  searchDialogTitle?: string;
  searchDialogIcon?: string;
  onCreateDialogsClick?: () => void;
  createDialogTitle?: string;
  createDialogIcon?: string;
  onClearDialogsClick?: () => void;
  clearTitle?: string;
  clearIcon?: string;
}

/**
 * Experimental Tags component to serve as an alternative to aggregation->association collections.
 */
export function Tags<P, T>(props: TagsProps<P, T>) {
  const {
    id,
    label,
    ownerData,
    name,
    error,
    readOnly = false,
    disabled = false,
    helperText,
    editMode = false,
    autoCompleteAttribute,
    onAutoCompleteSearch,
    onValueChange,
    onItemClick,
    onSearchDialogsClick,
    searchDialogTitle,
    searchDialogIcon = 'link',
    onCreateDialogsClick,
    createDialogTitle,
    createDialogIcon = 'file-document-plus',
    onClearDialogsClick,
    clearTitle = 'Clear',
    clearIcon = 'close',
    additionalMaskAttributes = [],
    limitOptions = 10,
    identifierAttribute,
  } = props;
  const [options, setOptions] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(false);

  const handleSearch = async (searchText: string) => {
    try {
      setLoading(true);
      const filter: { value: string, operator: any }[] = [];
      if (searchText) {
        filter.push({
          value: `%${searchText}%`,
          operator: StringOperation.like,
        });
      }
      const queryCustomizer: QueryCustomizer<any> = {
        _mask: `{${autoCompleteAttribute as string}${additionalMaskAttributes.length ? ',' + additionalMaskAttributes.join(',') : ''}}`,
        [autoCompleteAttribute]: filter,
        _orderBy: [
          {
            attribute: autoCompleteAttribute as string,
            descending: false,
          },
        ],
        _seek: {
          limit: limitOptions,
        },
      };
      const response = await onAutoCompleteSearch!(searchText, queryCustomizer);
      setOptions(response);
    } catch (error) {
      console.error(error);
      setOptions([]);
    } finally {
      setLoading(false);
    }
  };

  const onInputChange = useMemo(
    () =>
      debounce((event: any, value: string, reason: string) => {
        if (reason !== 'reset') {
          handleSearch(value);
        }
      }, debounceInputs),
    [ownerData],
  );

  const onChange = useCallback(
    (event: SyntheticEvent, value: (string | any)[]) => {
      if (typeof onValueChange === 'function') {
        onValueChange(value as any);
      }
    },
    [ownerData, onValueChange],
  );

  const onChipClicked = useCallback(
    (event: MouseEvent) => {
      const label = (event.target as HTMLSpanElement).textContent;
      if (label) {
        const data = ((ownerData[name] as T[]) ?? []).find((c: any) => c[autoCompleteAttribute] === label);
        if (data && onItemClick) {
          onItemClick(data);
        }
      }
    },
    [ownerData, onItemClick],
  );

  return (
    <Autocomplete
      multiple
      freeSolo
      clearOnBlur
      id={id}
      disabled={!readOnly && disabled}
      readOnly={readOnly}
      options={options}
      loading={loading}
      value={(ownerData[name] as T[]) ?? []}
      disableClearable={true}
      getOptionKey={(option) => option[identifierAttribute]}
      getOptionLabel={(option) => option[autoCompleteAttribute] ?? ''}
      isOptionEqualToValue={(option, value) => option[identifierAttribute] === value[identifierAttribute]}
      onOpen={ onAutoCompleteSearch ? () => {
        setOptions([]); // always start with a clean slate
        handleSearch('');
      } : undefined }
      onInputChange={onInputChange}
      onChange={onChange}
      renderInput={(params) => (
        <TextField
          {...params}
          label={label}
          className={clsx({
            'JUDO-viewMode': !editMode,
          })}
          error={error}
          helperText={helperText}
          InputLabelProps={ { shrink: true } }
          InputProps={ {
            ...params.InputProps,
            readOnly: readOnly,
            endAdornment: (
              <InputAdornment position="end">
                <ButtonGroup
                  aria-label="tags button group"
                  className={clsx({
                    'TagsButtonGroup': true,
                  })}
                >
                  {loading ? <CircularProgress color="inherit" size="1rem" className="TagsLoading" /> : null}
                  {!readOnly && onClearDialogsClick ? (
                    <IconButton disabled={disabled} onClick={onClearDialogsClick} title={clearTitle}>
                      <MdiIcon path={clearIcon} />
                    </IconButton>
                  ) : null}
                  {!readOnly && onCreateDialogsClick ? (
                    <IconButton disabled={disabled} onClick={onCreateDialogsClick} title={createDialogTitle}>
                      <MdiIcon path={createDialogIcon} />
                    </IconButton>
                  ) : null}
                  {!readOnly && onSearchDialogsClick ? (
                    <IconButton disabled={disabled} onClick={onSearchDialogsClick} title={searchDialogTitle}>
                      <MdiIcon path={searchDialogIcon} />
                    </IconButton>
                  ) : null}
                </ButtonGroup>
              </InputAdornment>
            ),
          } }
        />
      )}
      ChipProps={ {
        clickable: typeof onItemClick === 'function',
        onClick: onChipClicked,
      } }
    />
  );
}
