{{> fragment.header.hbs }}

import { type MouseEvent, type SyntheticEvent, useCallback, useMemo, useState } from 'react';
import clsx from 'clsx';
import InputAdornment from '@mui/material/InputAdornment';
import ButtonGroup from '@mui/material/ButtonGroup';
import CircularProgress from '@mui/material/CircularProgress';
import IconButton from '@mui/material/IconButton';
import Autocomplete from '@mui/material/Autocomplete';
import TextField from '@mui/material/TextField';
import { MdiIcon } from '~/components/MdiIcon';
import { debounce } from '@mui/material/utils';
import { debounceInputs } from '~/config/general';
import { QueryCustomizer } from '~/services/data-api/common/QueryCustomizer';
import { FilterBytypesString } from '~/services/data-api/rest/FilterBytypesString';
import { StringOperation } from '~/services/data-api/model/StringOperation';

export interface TagsProps<P, T> {
  id: string;
  label: string;
  ownerData: P;
  name: keyof P;
  error?: boolean;
  readOnly?: boolean;
  disabled?: boolean;
  helperText?: string;
  editMode?: boolean;
  autoCompleteAttribute: keyof T;
  onAutoCompleteSearch: (searchText: string, preparedQueryCustomizer: QueryCustomizer<T>) => Promise<T[]>;
  additionalMaskAttributes?: string[];
  limitOptions?: number;
  onValueChange: (target: T[]) => Promise<void>;
  onItemClick?: (target: T) => void;
  onSearchDialogsClick?: () => void;
  searchDialogTitle?: string;
  searchDialogIcon?: string;
  onCreateDialogsClick?: () => void;
  createDialogTitle?: string;
  createDialogIcon?: string;
  onClearDialogsClick?: () => void;
  clearTitle?: string;
  clearIcon?: string;
}

/**
 * Experimental Tags component to serve as an alternative to aggregation->association collections.
*/
export function Tags<P, T> (props: TagsProps<P, T>) {
  const {
    id,
    label,
    ownerData,
    name,
    error,
    readOnly = false,
    disabled = false,
    helperText,
    editMode = false,
    autoCompleteAttribute,
    onAutoCompleteSearch,
    onValueChange,
    onItemClick,
    onSearchDialogsClick,
    searchDialogTitle,
    searchDialogIcon = 'link',
    onCreateDialogsClick,
    createDialogTitle,
    createDialogIcon = 'file-document-plus',
    onClearDialogsClick,
    clearTitle= 'Clear',
    clearIcon = 'close',
    additionalMaskAttributes = [],
    limitOptions = 10,
  } = props;
  const [options, setOptions] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(false);

  const handleSearch = async (searchText: string) => {
    try {
      setLoading(true);
      const filter: FilterBytypesString[] = (ownerData[name] as T[] ?? []).map((c: any) => ({
        value: c[autoCompleteAttribute]!,
        operator: StringOperation.notEqual,
      }));
      if (searchText) {
        filter.push({
          value: `%${searchText}%`,
          operator: StringOperation.like,
        });
      }
      const queryCustomizer: QueryCustomizer<any> = {
        _mask: `{${autoCompleteAttribute as string}${additionalMaskAttributes.length ? (',' + additionalMaskAttributes.join(',')) : ''}}`,
        [autoCompleteAttribute]: filter,
        _orderBy: [
          {
            attribute: autoCompleteAttribute as string,
            descending: false,
          }
        ],
        _seek: {
          limit: limitOptions,
        },
      };
      const response = await onAutoCompleteSearch(searchText, queryCustomizer);
      setOptions(response);
    } catch (error) {
      console.error(error);
      setOptions([]);
    } finally {
      setLoading(false);
    }
  };

  const onInputChange = useMemo(
    () =>
      debounce((event: any, value: string, reason: string) => {
        if (reason !== 'reset') {
          handleSearch(value);
        }
      }, debounceInputs),
    [ownerData],
  );

  const onChange = useCallback((event: SyntheticEvent, value: (string | any)[]) => {
    onValueChange(value as any);
  }, [ownerData, onValueChange]);

  const onChipClicked = useCallback((event: MouseEvent) => {
    const label = (event.target as HTMLSpanElement).textContent;
    if (label) {
      const data = (ownerData[name] as T[] ?? []).find((c: any) => c[autoCompleteAttribute] === label);
      if (data && onItemClick) {
        onItemClick(data);
      }
    }
  }, [ownerData, onItemClick]);

  return (
    <Autocomplete
      multiple
      freeSolo
      clearOnBlur
      id={id}
      disabled={!readOnly && disabled}
      readOnly={readOnly}
      options={options}
      loading={loading}
      value={ownerData[name] as T[] ?? []}
      disableClearable={true}
      getOptionLabel={(option) => option[autoCompleteAttribute] ?? ''}
      isOptionEqualToValue={(option, value) => option[autoCompleteAttribute] === value[autoCompleteAttribute]}
      onOpen={ () => {
        setOptions([]); // always start with a clean slate
        handleSearch('');
      } }
      onInputChange={onInputChange}
      onChange={onChange}
      renderInput={(params) => (
        <TextField
          {...params}
          label={label}
          className={clsx({
            'JUDO-viewMode': !editMode,
          })}
          error={error}
          helperText={helperText}
          InputProps={ {
            ...params.InputProps,
            readOnly: readOnly,
            endAdornment: (
              <InputAdornment position="end">
                <ButtonGroup
                  aria-label="tags button group"
                  className={clsx({
                    'TagsButtonGroup': true,
                  })}
                >
                  {loading ? (
                    <CircularProgress color="inherit" size="1rem" className="TagsLoading" />
                  ) : null}
                  {!readOnly && onClearDialogsClick ? (
                    <IconButton disabled={disabled} onClick={onClearDialogsClick} title={clearTitle}>
                      <MdiIcon path={clearIcon} />
                    </IconButton>
                  ) : null}
                  {(!readOnly && onCreateDialogsClick) ? <IconButton
                    disabled={disabled}
                    onClick={onCreateDialogsClick}
                    title={createDialogTitle}
                  >
                    <MdiIcon path={createDialogIcon} />
                  </IconButton> : null}
                  {(!readOnly && onSearchDialogsClick) ? <IconButton
                    disabled={disabled}
                    onClick={onSearchDialogsClick}
                    title={searchDialogTitle}
                  >
                    <MdiIcon path={searchDialogIcon} />
                  </IconButton> : null}
                </ButtonGroup>
              </InputAdornment>
            ),
          } }
        />
      )}
      ChipProps={ {
        clickable: typeof onItemClick === 'function',
        onClick: onChipClicked,
      } }
    />
  );
};
