= UI React
ifndef::env-site,env-github[]
endif::[]
// Settings
:idprefix:
:idseparator: -
:icons: font
:KW: [purple]##**
:KWE: **##

JUDO React frontend generator templates.

== Architecture

WIP

== Customization

There are two major ways how JUDO apps can be customized with various pros / cons:

- Template overrides
- Providing custom implementations for certain interfaces

Customization via template overrides is discussed at the https://github.com/BlackBeltTechnology/judo-meta-ui/tree/develop/generator-maven-plugin[ judo-meta-ui/generator-maven-plugin]
repository.

In this documentation we will only discuss customization via interface implementation.

=== Context

JUDO frontend applications utilize the https://github.com/BlackBeltTechnology/pandino[Pandino] library. This library can
be considered as a "dependency injection framework on steroids".

For details about Pandino, please check its corresponding documentation.

Regardless of documentation, the fastest way of figuring out what interfaces can be re-implemented is by searching for:

- `ComponentProxy` components
- `useTrackService<T>()` hooks

All of these usually consume at least a `filter` parameter and where applicable refer to a `T` generic type.

> All customizable interfaces have a `string` representation (INTERFACE_KEY) since at the end of the day, JavaScript doesn't support
  interfaces and we need to pair them up.

=== First step

The entry point for registering implementations is `src/custom/application-customizer.tsx`.

[WARNING]
====
This file MUST be put into the `.generator-ignore` file and should be added to Git, otherwise whatever we put into it
will be replaced by the generator.
====

You may put your implementations anywhere inside the project, the only purpose of the `application-customizer.tsx` file
is to be the entry point for registration.

=== Implementing pages

Interface keys for pages can be found at `src/routes.tsx` with their actual implementation pairs next to them.

[source,typescriptjsx]
----
import type { FC } from 'react';
import type { BundleContext } from '@pandino/pandino-api';
import type { ApplicationCustomizer } from './interfaces';
import { ROUTE_GOD_GALAXIES_TABLE_INTERFACE_KEY } from '../routes';

export class DefaultApplicationCustomizer implements ApplicationCustomizer {
  async customize(context: BundleContext): Promise<void> {
    context.registerService<FC>(ROUTE_GOD_GALAXIES_TABLE_INTERFACE_KEY, CustomGalaxies);
  }
}

export const CustomGalaxies = () => {
  return (
    <div className="galaxies">
      <img src="https://c.tenor.com/rtnshG9YFykAAAAM/rick-astley-rick-roll.gif" />
    </div>
  );
};
----

=== Implementing the localization loader

The localization loader is responsible for loading the translations for the application.

We need to implement the `L10NTranslationProvider` interface (`L10N_TRANSLATION_PROVIDER_INTERFACE_KEY`).

[source,typescriptjsx]
----
import type { BundleContext } from '@pandino/pandino-api';
import type { ApplicationCustomizer } from './interfaces';
import {
  L10N_TRANSLATION_PROVIDER_INTERFACE_KEY,
  L10NTranslationProvider,
  L10NTranslations,
} from '../l10n/l10n-context';

export class DefaultApplicationCustomizer implements ApplicationCustomizer {
  async customize(context: BundleContext): Promise<void> {
    context.registerService(L10N_TRANSLATION_PROVIDER_INTERFACE_KEY, new CustomL10NProvider());
  }
}

class CustomL10NProvider implements L10NTranslationProvider {
  async provideTranslations(locale: string): Promise<L10NTranslations> {
    return Promise.resolve({
      systemTranslations: {
        'judo.pages.create': 'My Create Label',
        // ...
      },
      applicationTranslations: {
        'God.galaxies.View.group.group.2.group.2.constellation': 'cOnStElLaTiOn',
        // ...
      },
    });
  }
}
----

=== Implementing a custom error processor

Errors which may be triggered by the application can be customized. The level of customization only applies to:

- response toast triggering
- response toast message
- validation error feedbacks

Whether and what errors are triggered cannot be modified!

The pattern with regards to how can this be achieved is similar to the previous.

You need to register a service for the `ERROR_PROCESSOR_HOOK_INTERFACE_KEY` with variable service parameters depending
on the error handler in question.

> This is due to the fact that different types of errors may be configured in a more general or specific way, and service
  properties help target these services.

In the following example we will customize the validation error message for the `MISSING_REQUIRED_ATTRIBUTE` error code
only for a certain `Create` operation, and everything else will behave as per default.

[source,typescriptjsx]
----
import { useTranslation } from 'react-i18next';
import type { BundleContext } from '@pandino/pandino-api';
import type { ApplicationCustomizer } from './interfaces';
import type { ErrorHandlingOption, ErrorProcessorHook, ErrorProcessResult, ServerError } from '../utilities/error-handling';
import { ERROR_PROCESSOR_HOOK_INTERFACE_KEY } from '../utilities/error-handling';
import { useSnackbar } from '../components';
import { ViewGalaxy } from '../generated/data-api';

export class DefaultApplicationCustomizer implements ApplicationCustomizer {
  async customize(context: BundleContext): Promise<void> {
    // Mind the service parameters! Without these, our registration wouldn't match.
    context.registerService<ErrorProcessorHook<ViewGalaxy>>(ERROR_PROCESSOR_HOOK_INTERFACE_KEY, galaxiesCreateFormErrorHook, {
      operation: 'Create',
      component: 'PageCreateGalaxiesForm',
    });
  }
}

const galaxiesCreateFormErrorHook: ErrorProcessorHook<ViewGalaxy> = () => {
  const { t } = useTranslation();
  const [enqueueSnackbar] = useSnackbar();

  /**
   * @param {ErrorProcessResult} defaultResults Contains the pre-filled results, the usage is optional
   * @param {any} [payload] Is present depending on the use-case, usually contains the data sent to the backend
   */
  return (error: any, defaultResults: ErrorProcessResult, options?: ErrorHandlingOption, payload?: ViewGalaxy) => {
    // only modify validation results
    if (error?.response?.status === 400) {
      const errorList = error.response.data as ServerError[];
      // if the host page has validation errors turned on
      if (typeof options?.setValidation === 'function' && defaultResults.validation) {
        // filter errors where we know the affected field's name
        errorList.filter((e) => e.location).forEach((error) => {
          // only modify prepared results for required errors
          if (error.code === 'MISSING_REQUIRED_ATTRIBUTE') {
            defaultResults.validation.set(error.location, t('you forgot to fill this') as string);
          }
        });

        options.setValidation(defaultResults.validation);
      }
    }

    // if by default we have a toast message, display it, but we can enforce the same by calling
    // `enqueueSnackbar()` without any condition.
    if (defaultResults.toastMessage) {
      enqueueSnackbar(defaultResults.toastMessage, defaultResults.errorToastConfig);
    }
  };
};
----

As explained in the comments, **the provisioning of service parameters is mandatory!**

The best way to find out what services requires what parameters, you only need to search for the `useErrorHandler` hook's
usage, and you should be able to see how does the corresponding `filter` look like.

=== Implementing a custom visual element

Every Visual element implementation can be replaced by a custom one, given in the model the `customImplementation`
flag has been set for such element.

Types of elements included:

- Boxes / Cards (flex)
- Inputs
- Labels
- etc...

Once the flag has been set, a corresponding interface and `ComponentProxy` will be generated into the Page where the
visual element resides in.

Example: If we toggle the `customImplementation` flag for a TextInput element called `yayy` on the create page of
`CustomStuffz`, The following will be generated:

*PageCreateStuffzForm.tsx:*
[source,typescriptjsx]
----
import { FC } from 'react';
import { OBJECTCLASS } from '@pandino/pandino-api';
import { SomethingTransfer, SomethingTransferStored } from '../../../../../generated/data-api';
import { CUSTOM_VISUAL_ELEMENT_INTERFACE_KEY, CustomFormVisualElementProps } from '../../../../../custom';

export const COMPONENT_ACTOR_CREATE_YAYY = 'ComponentActorCreateYayy';
export interface ComponentActorCreateYayy extends FC<CustomFormVisualElementProps<SomethingTransfer>> {}

export interface PageCreateStuffzFormProps {
  successCallback: (result: SomethingTransferStored) => void;
  cancel: () => void;
}

export function PageCreateStuffzForm({ successCallback, cancel }: PageCreateStuffzFormProps) {
  // ...

  return (
    <>
      {/* ... */}
        <ComponentProxy
          filter={`(&(${OBJECTCLASS}=${CUSTOM_VISUAL_ELEMENT_INTERFACE_KEY})(component=${COMPONENT_ACTOR_CREATE_YAYY}))`}
          data={data}
          validation={validation}
          editMode={editMode}
          storeDiff={storeDiff}
          payloadDiff={payloadDiff}
        >
          <TextField
              name="yayy"
              {/* ... */}
          />
        </ComponentProxy>
      {/* ... */}
    </>
  );
}
----

As we can see the `TextField` component has been wrapped in a `ComponentProxy` component which will search for an
implementation, and if not found, loads the child.

If we would like to re-implement this component, we will need to use the following (as per the filter criteria):

- `CUSTOM_VISUAL_ELEMENT_INTERFACE_KEY`: which is the generic interface for custom components
- `ComponentActorCreateYayy`: which is the non-generic / resolved interface for our component
- `COMPONENT_ACTOR_CREATE_YAYY`: which is a unique string representing the corresponding  interface above


*src/custom/application-customizer.tsx:*
[source,typescriptjsx]
----
import { useMemo } from 'react';
import type { BundleContext } from '@pandino/pandino-api';
import { ComponentActorCreateYayy, COMPONENT_ACTOR_CREATE_YAYY } from '../pages/component_actor/stuffz/table/actions/PageCreateStuffzForm';
import { ApplicationCustomizer } from './interfaces';
import { CUSTOM_VISUAL_ELEMENT_INTERFACE_KEY } from './custom-element-types';

export class DefaultApplicationCustomizer implements ApplicationCustomizer {
  async customize(context: BundleContext): Promise<void> {
    context.registerService(CUSTOM_VISUAL_ELEMENT_INTERFACE_KEY, OptimisticImplementationForYayy, {
      component: COMPONENT_ACTOR_CREATE_YAYY,
    })
  }
}

const OptimisticImplementationForYayy: ComponentActorCreateYayy = ({ data, storeDiff }) => {
  const yayy = useMemo<string | undefined | null>(() => data.yayy, [data.yayy]);

  return (
    <div>
      <label htmlFor="custom-yayy">Our own Yayy:</label>
      <input type="text" id="custom-yayy" maxLength={12} value={yayy as string} onChange={(event) => storeDiff('yayy', event.target.value)} />
    </div>
  );
};
----

> Of course our custom components can be placed / imported from anywhere in the source code. We just simplified it in
  the use-case above.

=== Implementing custom navigation logic for components

Navigation actions are implemented as hooks. These hooks have names starting with "useRow..." in case of tables and
"useLink..." in case of single relations.

Given we have a table screen listing galaxies, we can implement a custom navigation logic in the following way:

*Generated hook (original code):*
[source,typescriptjsx]
----
import { OBJECTCLASS } from '@pandino/pandino-api';
import { useTrackService } from '@pandino/react-hooks';
import type { JudoIdentifiable } from '@judo/data-api-common';
import type { ViewGalaxyQueryCustomizer, ViewGalaxy, ViewGalaxyStored } from '../../../../../../generated/data-api';
import { useJudoNavigation } from '../../../../../../components';

export const ROW_VIEW_GALAXIES_ACTION_INTERFACE_KEY = 'RowViewGalaxiesAction';
export type RowViewGalaxiesAction = () => (entry: ViewGalaxyStored) => Promise<void>;

export const useRowViewGalaxiesAction: RowViewGalaxiesAction = () => {
  const { navigate } = useJudoNavigation();
  const { service: useCustomNavigation } = useTrackService<RowViewGalaxiesAction>(
    `(${OBJECTCLASS}=${ROW_VIEW_GALAXIES_ACTION_INTERFACE_KEY})`,
  );

  if (useCustomNavigation) {
    const customNavigation = useCustomNavigation();
    return customNavigation;
  }

  return async function (entry: ViewGalaxyStored) {
    navigate(`god/galaxies/view/${entry.__signedIdentifier}`);
  };
};
----

Overriding the above logic can ge done by:

- implementing the `RowViewGalaxiesAction` interface
- registering this implementation in the `application-customizer.tsx` file

> For brevity's sake we'll put all our code in a single file, but it's not mandatory

*src/custom/application-customizer.tsx:*
[source,typescriptjsx]
----
import type { BundleContext } from '@pandino/pandino-api';
import { useJudoNavigation } from '../components';
import { ViewGalaxyStored } from '../generated/data-api';
import { RowViewGalaxiesAction, ROW_VIEW_GALAXIES_ACTION_INTERFACE_KEY } from '../pages/god/galaxies/table/actions';
import { ApplicationCustomizer } from './interfaces';

export class DefaultApplicationCustomizer implements ApplicationCustomizer {
  async customize(context: BundleContext): Promise<void> {
    context.registerService<RowViewGalaxiesAction>(ROW_VIEW_GALAXIES_ACTION_INTERFACE_KEY, customRowViewGalaxiesAction);
  }
}

const customRowViewGalaxiesAction: RowViewGalaxiesAction = () => {
  const { navigate } = useJudoNavigation();

  return async (entry: ViewGalaxyStored) => {
    // regardless of what row we select, we will always go to the same page
    navigate('god/earth/view');
  }
};
----

=== Implementing custom behaviour for operation success handling

Every custom operation has a "success handler" implementation by default. These handlers behave differently depending on
the action type, and return parameter (or lack thereof).

*Default behaviours explained:*

- if there is a *mapped* return type:
  * pop a success toast and
  * navigate to the created element's view page
- if there is an *unmapped* return type:
  * pop a success toast and
  * refresh the current page and
  * show the result in a read-only modal
- if there is no return type:
  * pop a success toast and
  * refresh the current page

*Overriding the above logic can ge done by:*

- implementing the `PostHandlerHook` interface for an operation
- registering this implementation in the `application-customizer.tsx` file

Depending on what operation we would like to override, we need to locate the action in the `src/pages` folder, and once
we found our action file, we should be able to see an `INTERFACE_KEY` with the corresponding `PostHandlerHook` interface.

> Please be aware that the interfaces for each hook have different signatures based on the operation, e.g.: for operations
  which do not have a return type, the corresponding hook interfaces won't contain a "result" parameter!

*src/custom/application-customizer.tsx:*
[source,typescriptjsx]
----
import type { BundleContext } from '@pandino/pandino-api';
import { useSnackbar } from 'notistack';
import { ApplicationCustomizer } from './interfaces';
import {
  ADMIN_DASHBOARD_CREATE_ISSUE_ACTION_POST_HANDLER_HOOK_INTERFACE_KEY,
  AdminDashboardCreateIssueActionPostHandlerHook
} from '../pages/admin/admin/dashboardhome/actions';
import { AdminIssueStored } from '../generated/data-api';
import { toastConfig } from '../config';

export class DefaultApplicationCustomizer implements ApplicationCustomizer {
  async customize(context: BundleContext): Promise<void> {
    context.registerService(ADMIN_DASHBOARD_CREATE_ISSUE_ACTION_POST_HANDLER_HOOK_INTERFACE_KEY, usePostIssueCreated);
  }
}

const usePostIssueCreated: AdminDashboardCreateIssueActionPostHandlerHook = () => {
  const { enqueueSnackbar } = useSnackbar();
  // We can add any variables and use any hooks here

  return (ownerCallback: () => void, result?: AdminIssueStored) => {
    // The default implementation in this case is to pop a generic toast, and navigate to the created element's page
    // but we are overriding this, to only pop a custom toast message
    if (result) {
      enqueueSnackbar(`${result.title} created!`, {
        variant: 'success',
        ...toastConfig.success,
      });
    }

    // and regardless of the output, refresh the current page
    ownerCallback();
  };
};
----

Since operations are always started from modal windows the `ownerCallback` can behave differently, but most of the time
it triggers a refresh on the actual page which we resided on.

If we would like to implement a fix navigation to some page, it is recommended to *NOT CALL* the `ownerCallback()` function
to prevent unnecessary REST calls and potential screen flow issues.
